%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Global variables used in the language (only 'p' and 'q' supported)
int p = 0, q = 0;

// Error reporting function called by Bison on syntax errors
void yyerror(const char *s) { fprintf(stderr, "Error: %s\n", s); }

// Declaration for the lexer function generated by Flex
int yylex(void);

// AST Node Type Enums
// Statement types: assignment, if-statement, while-loop, print
typedef enum { STMT_ASSIGN, STMT_IF, STMT_WHILE, STMT_PRINT } StmtType;

// Expression types: numbers, variable names, addition, subtraction
typedef enum { EXPR_NUMBER, EXPR_IDENTIFIER, EXPR_PLUS, EXPR_MINUS } ExprType;

// Condition types: greater-than, less-than, equals
typedef enum { COND_GT, COND_LT, COND_EQ } CondType;

// AST Node Structures
// Expression node: for literals, identifiers, and binary operations
struct expr_node {
    ExprType type;
    union {
        int num_val;                  // For literal numbers
        char *var_name;              // For variables (like p, q)
        struct { struct expr_node *left, *right; } bin_op;  // For +, -
    } data;
};

// Condition node: comparisons between variables only
struct cond_node {
    CondType type;
    char *left_var_name, *right_var_name;
};

// Statement node: supports assignment, if-else, while, print
struct stmt_node {
    StmtType type;
    union {
        struct { char *var_name; struct expr_node *expr; } assign_stmt;
        struct { struct cond_node *condition; struct stmt_node *then_body, *else_body; } if_stmt;
        struct { struct cond_node *condition; struct stmt_node *body; } while_stmt;
        struct { char *var_name; } print_stmt;
    } data;
    struct stmt_node *next; // Linked list for sequencing statements
};

// AST Node Constructors
// Create a number expression node
struct expr_node* create_num_expr(int val) {
    struct expr_node *n = malloc(sizeof(*n));
    n->type = EXPR_NUMBER;
    n->data.num_val = val;
    return n;
}

// Create an identifier expression node (for variables)
struct expr_node* create_id_expr(char *v) {
    struct expr_node *n = malloc(sizeof(*n));
    n->type = EXPR_IDENTIFIER;
    n->data.var_name = strdup(v);  // Duplicate the string
    return n;
}

// Create a binary expression node (+ or -)
struct expr_node* create_bin_expr(ExprType t, struct expr_node *l, struct expr_node *r) {
    struct expr_node *n = malloc(sizeof(*n));
    n->type = t;
    n->data.bin_op.left = l;
    n->data.bin_op.right = r;
    return n;
}

// Create a condition node (variable comparisons)
struct cond_node* create_condition(CondType t, char *l, char *r) {
    struct cond_node *n = malloc(sizeof(*n));
    n->type = t;
    n->left_var_name = strdup(l);
    n->right_var_name = strdup(r);
    return n;
}

// Create an assignment statement node
struct stmt_node* create_assign_stmt_node(char *v, struct expr_node *e) {
    struct stmt_node *n = malloc(sizeof(*n));
    n->type = STMT_ASSIGN;
    n->data.assign_stmt.var_name = strdup(v);
    n->data.assign_stmt.expr = e;
    n->next = NULL;
    return n;
}

// Create an if-else statement node
struct stmt_node* create_if_stmt_node(struct cond_node *c, struct stmt_node *t, struct stmt_node *e) {
    struct stmt_node *n = malloc(sizeof(*n));
    n->type = STMT_IF;
    n->data.if_stmt.condition = c;
    n->data.if_stmt.then_body = t;
    n->data.if_stmt.else_body = e;
    n->next = NULL;
    return n;
}

// Create a while-loop statement node
struct stmt_node* create_while_stmt_node(struct cond_node *c, struct stmt_node *b) {
    struct stmt_node *n = malloc(sizeof(*n));
    n->type = STMT_WHILE;
    n->data.while_stmt.condition = c;
    n->data.while_stmt.body = b;
    n->next = NULL;
    return n;
}

// Create a print statement node
struct stmt_node* create_print_stmt_node(char *v) {
    struct stmt_node *n = malloc(sizeof(*n));
    n->type = STMT_PRINT;
    n->data.print_stmt.var_name = strdup(v);
    n->next = NULL;
    return n;
}

// Interpreter Functions
// Get current value of a variable (only p and q supported)
int get_var_value(char *v) {
    if (strcmp(v, "p") == 0) return p;
    if (strcmp(v, "q") == 0) return q;
    fprintf(stderr, "Unknown variable %s\n", v); exit(1);
}

// Set the value of a variable
void set_var_value(char *v, int val) {
    printf("[INFO] %s = %d\n", v, val);
    if (strcmp(v, "p") == 0) p = val;
    else if (strcmp(v, "q") == 0) q = val;
}

// Recursively evaluate an expression tree
int evaluate_expr(struct expr_node *n) {
    if (!n) return 0;
    switch (n->type) {
        case EXPR_NUMBER: return n->data.num_val;
        case EXPR_IDENTIFIER: return get_var_value(n->data.var_name);
        case EXPR_PLUS: {
            int l = evaluate_expr(n->data.bin_op.left);
            int r = evaluate_expr(n->data.bin_op.right);
            printf("[INFO] Evaluating: %d + %d = %d\n", l, r, l + r);
            return l + r;
        }
        case EXPR_MINUS: {
            int l = evaluate_expr(n->data.bin_op.left);
            int r = evaluate_expr(n->data.bin_op.right);
            printf("[INFO] Evaluating: %d - %d = %d\n", l, r, l - r);
            return l - r;
        }
    }
    return 0;
}

// Evaluate a condition
int evaluate_condition(struct cond_node *c) {
    int l = get_var_value(c->left_var_name);
    int r = get_var_value(c->right_var_name);
    const char *op;
    int result;
    switch (c->type) {
        case COND_GT: op = ">"; result = l > r; break;
        case COND_LT: op = "<"; result = l < r; break;
        case COND_EQ: op = "=="; result = l == r; break;
    }
    printf("[INFO] Condition (%s %s %s): %d %s %d is %s\n",
           c->left_var_name, op, c->right_var_name,
           l, op, r, result ? "TRUE" : "FALSE");
    return result;
}

// Execute a single statement
void execute_stmt(struct stmt_node *n);

// Execute a list of statements
void execute_stmt_list(struct stmt_node *n) {
    while (n) {
        execute_stmt(n);
        n = n->next;
    }
}

// Dispatch execution based on statement type
void execute_stmt(struct stmt_node *n) {
    if (!n) return;
    switch (n->type) {
        case STMT_ASSIGN:
            set_var_value(n->data.assign_stmt.var_name, evaluate_expr(n->data.assign_stmt.expr));
            break;
        case STMT_PRINT:
            printf("[INFO] PRINT %s: %d\n", n->data.print_stmt.var_name, get_var_value(n->data.print_stmt.var_name));
            break;
        case STMT_IF:
            if (evaluate_condition(n->data.if_stmt.condition))
                execute_stmt_list(n->data.if_stmt.then_body);
            else
                execute_stmt_list(n->data.if_stmt.else_body);
            break;
        case STMT_WHILE:
            while (evaluate_condition(n->data.while_stmt.condition))
                execute_stmt_list(n->data.while_stmt.body);
            break;
    }
}
%}

// Bison Declarations
// Define types returned by lexer tokens and used in grammar rules
%union {
    int ival;                              // For numbers
    char* sval;                            // For identifiers (variable names)
    struct stmt_node *stmt_ptr;           // For statement nodes
    struct expr_node *expr_ptr;           // For expression nodes
    struct cond_node *cond_ptr;           // For condition nodes
}

// Terminal tokens
%token <sval> IDENTIFIER
%token <ival> NUMBER
%token WHILE IF THEN ELSE PRINT
%token ASSIGN GT LT EQ PLUS MINUS SEMI LBRACE RBRACE

// Non-terminal return types
%type <expr_ptr> expr
%type <cond_ptr> condition
%type <stmt_ptr> stmt_list stmt

%%

// Grammar Rules
// Entry point of the program
program:
    stmt_list { execute_stmt_list($1); }
    ;

// Sequence of statements (linked list)
stmt_list:
      stmt_list stmt {
          struct stmt_node *temp = $1;
          while (temp->next) temp = temp->next;
          temp->next = $2;
          $$ = $1;
      }
    | stmt { $$ = $1; }
    ;

// Statement: assignment, while-loop, if-else, print
stmt:
      IDENTIFIER ASSIGN expr SEMI {
          $$ = create_assign_stmt_node($1, $3);
      }
    | WHILE '(' condition ')' LBRACE stmt_list RBRACE {
          $$ = create_while_stmt_node($3, $6);
      }
    | IF condition THEN stmt ELSE stmt {
          $$ = create_if_stmt_node($2, $4, $6);
      }
    | PRINT IDENTIFIER SEMI {
          $$ = create_print_stmt_node($2);
      }
    ;

// Conditions: comparisons between two identifiers
condition:
      IDENTIFIER GT IDENTIFIER { $$ = create_condition(COND_GT, $1, $3); }
    | IDENTIFIER LT IDENTIFIER { $$ = create_condition(COND_LT, $1, $3); }
    | IDENTIFIER EQ IDENTIFIER { $$ = create_condition(COND_EQ, $1, $3); }
    ;

// Expressions: numbers, identifiers, binary operations
expr:
      NUMBER { $$ = create_num_expr($1); }
    | IDENTIFIER { $$ = create_id_expr($1); }
    | expr PLUS expr { $$ = create_bin_expr(EXPR_PLUS, $1, $3); }
    | expr MINUS expr { $$ = create_bin_expr(EXPR_MINUS, $1, $3); }
    ;

%%

// Main Function
int main() {
    printf("=== Starting Parser\n");
    yyparse();  // Start the parser
    printf("=== Parsing Complete\n");
    return 0;
}
