# Compiler Flow: From Source Code to Machine Code

This document describes the complete flow of the compiler implementation, from source code input to final code generation.

## Overview

The compiler follows a traditional multi-phase architecture:
1. **Lexical Analysis** (Tokenization)
2. **Syntax Analysis** (Parsing & AST Construction)
3. **Semantic Analysis** (Symbol Tables & Type Checking)
4. **Code Generation** (IR, Assembly)

---

## Entry Point: `main.c`

**Starting Point:** `main.c` - The compiler's entry point

**Function:** `main(int argc, char **argv)`

**Input:** Source file path (e.g., `program.src`)

**Flow:**
```
main.c
  ├─> Initialize lexer support structures
  ├─> Open source file → scanner.l (via yyin)
  ├─> Call yyparse() → parser.y
  ├─> Receive AST root → astRoot
  ├─> Call semantic_passA() → semantic.c
  ├─> Call semantic_passB() → semantic.c
  └─> Call codegen functions → codegen.c
```

---

## Phase 1: Lexical Analysis

### File: `scanner.l` (Flex/Lex source)

**Generated Files:**
- `scanner.yy.c` (generated by Flex)
- `lexer_tokens.txt` (output)
- `lexer_symbols.txt` (output)
- `lexer_errors.txt` (output)

**Dependencies:**
- `lexer_support.h` / `lexer_support.c` - Token/symbol tracking
- `parser.tab.h` - Token definitions (generated by Bison)
- `ast.h` - For location tracking

**Process:**
1. Reads source file character by character (via `yyin` from `main.c`)
2. Matches patterns using regular expressions
3. Returns tokens to parser via `yylex()`
4. Records tokens/symbols/errors via `lexer_support.c` functions

**Output:**
- Token stream → `parser.y` (via `yylex()`)
- Token trace → `lexer_tokens.txt`
- Symbol table → `lexer_symbols.txt`
- Lexical errors → `lexer_errors.txt`

---

## Phase 2: Syntax Analysis

### File: `parser.y` (Bison/Yacc source)

**Generated Files:**
- `parser.tab.c` (generated by Bison)
- `parser.tab.h` (generated by Bison - token definitions)
- `derivation_steps.txt` (output)
- `syntax_error.txt` (output)

**Dependencies:**
- `scanner.l` → `yylex()` for tokens
- `ast.h` / `ast.c` - AST node creation
- `lexer_support.h` - Location tracking

**Process:**
1. Receives tokens from `yylex()` (called by Bison)
2. Matches tokens against grammar rules
3. Builds AST nodes using `ast.c` functions
4. Logs derivation steps to `derivation_steps.txt`
5. Records syntax errors to `syntax_error.txt`

**Output:**
- AST root node → `astRoot` (global variable, used by `main.c`)
- Derivation log → `derivation_steps.txt`
- Syntax errors → `syntax_error.txt`

**Key Functions:**
- `yyparse()` - Bison-generated parser (called from `main.c`)
- `yyerror()` - Error handler (writes to `syntax_error.txt`)
- `log_production()` - Logs grammar rule applications

---

## Phase 3: Semantic Analysis

### File: `semantic.c`

**Generated Files:**
- `semantic_errors.txt` (output)
- `symbol_table.txt` (output, via `symbol_table.c`)

**Dependencies:**
- `ast.h` / `ast.c` - AST traversal
- `symbol_table.h` / `symbol_table.c` - Symbol table management

**Process:**

#### Pass A: Symbol Table Building
1. Traverses AST starting from root
2. Creates symbol tables for each scope (global, function, class, block)
3. Inserts symbols: classes, functions, variables, parameters, attributes
4. Calculates stack frame offsets for variables/parameters
5. Detects duplicate declarations

**Function:** `semantic_passA(AST *root)`

#### Pass B: Type Checking
1. Traverses AST again
2. Resolves identifier types from symbol tables
3. Checks type compatibility in assignments
4. Validates function call arguments
5. Checks return type compatibility
6. Verifies all identifiers are declared

**Function:** `semantic_passB(AST *root)`

**Output:**
- Global symbol table → `globalTable` (used by codegen)
- Semantic errors → `semantic_errors.txt`
- Symbol table dump → `symbol_table.txt`

---

### Supporting Files: `symbol_table.c` / `symbol_table.h`

**Purpose:** Hierarchical symbol table management

**Key Functions:**
- `symtable_create()` - Create new scope
- `symtable_insert()` - Insert symbol into scope
- `symtable_lookup()` - Look up symbol (with lexical scoping)
- `symtable_print_all()` - Dump symbol table to file
- `symtable_type_size()` - Get memory size for types

**Used By:**
- `semantic.c` - Building and querying symbol tables
- `codegen.c` - Variable offsets, function information

---

## Phase 4: Code Generation

### Entry Point: `codegen.c` / `codegen.h`

**Generated Files:**
- `codegen.ir` (Intermediate Representation)
- `codegen.asm` (x86-32 Assembly)

**Dependencies:**
- `ast.h` / `ast.c` - AST traversal
- `symbol_table.h` / `symbol_table.c` - Variable offsets, function info

**Called From:** `main.c` (only if no semantic errors)

---

### Code Generation Flow

```
main.c (semanticErrors == 0)
  │
  ├─> codegen_generate_ir()
  │   └─> Generates: codegen.ir
  │
  ├─> codegen_generate()
  │   └─> Generates: codegen.asm
```

---

### 4.1 Intermediate Representation (IR) Generation

**Function:** `codegen_generate_ir(AST *root, SymTable *global, const char *outPath)`

**Process:**
1. Traverses AST starting from root
2. For each function:
   - Generates function header
   - Processes function body statements
   - Converts expressions to 3-address code format
   - Generates temporary variables (t0, t1, t2, ...)
3. Output format: `result = operand1 operator operand2`

**Output:** `codegen.ir` - Machine-independent 3-address code

**Example:**
```
function main:
  prologue
    t0 = load a
    t1 = t0 + 2
    t2 = t1 * 3
    store x, t2
    return t2
  epilogue
```

---

### 4.2 Assembly Code Generation

**Function:** `codegen_generate(AST *root, SymTable *global, const char *outPath)`

**Process:**

#### Initialization
1. Creates `CodeGenContext` for register management
2. Generates `.data` section for string/float literals
3. Sets up x86-32 architecture configuration

#### Function Generation
For each function in AST:
1. Creates `FunctionContext` with function scope
2. Generates function prologue:
   - `push EBP`
   - `mov EBP, ESP`
   - Save callee-saved registers (EBX, ESI, EDI if used)
   - Allocate stack space for local variables
3. Generates function body:
   - Traverses statements
   - Generates code for expressions
   - Manages register allocation/deallocation
4. Generates function epilogue:
   - Restore callee-saved registers
   - `mov ESP, EBP`
   - `pop EBP`
   - `ret`

#### Expression Code Generation
- **Variables:** Load from stack (EBP-offset for locals, EBP+offset for params)
- **Literals:** Move immediate values to registers
- **Binary Operations:** Generate appropriate x86 instructions (add, sub, mul, div, cmp, etc.)
- **Function Calls:** Push arguments right-to-left, call function, clean stack
- **Control Flow:** Generate labels and jump instructions

**Output:** `codegen.asm` - x86-32 assembly code

**Example:**
```asm
    .386
    .model flat, c
    .code

_main:
    push EBP
    mov EBP, ESP
    sub ESP, 4    ; reserve space for locals
    mov EAX, 5
    mov DWORD PTR [EBP-4], EAX    ; x (local)
    mov ESP, EBP
    pop EBP
    ret
```

---

## Supporting Data Structures

### AST (Abstract Syntax Tree)
**Files:** `ast.h` / `ast.c`

**Structure:**
- Tree of nodes representing program structure
- Each node has: kind, name, typeName, value, lineno, child, sibling, extra

**Used By:**
- `parser.y` - Builds AST during parsing
- `semantic.c` - Traverses AST for semantic analysis
- `codegen.c` - Traverses AST for code generation

---

### Symbol Table
**Files:** `symbol_table.h` / `symbol_table.c`

**Structure:**
- Hierarchical scopes (global → function → block)
- Each scope contains linked list of symbols
- Symbols store: name, type, kind, line number, offset, size

**Used By:**
- `semantic.c` - Builds and queries symbol tables
- `codegen.c` - Gets variable offsets and function information

---

## Complete File Dependency Graph

```
main.c
  │
  ├─> scanner.l (via yyin, yylex)
  │   ├─> lexer_support.h/c
  │   └─> parser.tab.h (generated)
  │
  ├─> parser.y (via yyparse)
  │   ├─> scanner.l (yylex)
  │   ├─> ast.h/c
  │   └─> lexer_support.h
  │
  ├─> semantic.c
  │   ├─> ast.h/c
  │   └─> symbol_table.h/c
  │
  └─> codegen.c
      ├─> ast.h/c
      └─> symbol_table.h/c
```

---

## Output Files Summary

| File | Generated By | Phase | Description |
|------|-------------|-------|-------------|
| `lexer_tokens.txt` | `lexer_support.c` | Lexical | Sequence of all tokens |
| `lexer_symbols.txt` | `lexer_support.c` | Lexical | Symbol frequency table |
| `lexer_errors.txt` | `lexer_support.c` | Lexical | Lexical errors |
| `derivation_steps.txt` | `parser.y` | Syntax | Grammar rule applications |
| `syntax_error.txt` | `parser.y` | Syntax | Syntax errors |
| `semantic_errors.txt` | `semantic.c` | Semantic | Semantic errors |
| `symbol_table.txt` | `symbol_table.c` | Semantic | Symbol table dump |
| `codegen.ir` | `codegen.c` | Code Gen | Intermediate Representation |
| `codegen.asm` | `codegen.c` | Code Gen | x86-32 Assembly |

---

## Code Generation Architecture Details

### Register Management
- **Register Pool:** EAX, EBX, ECX, EDX, ESI, EDI (6 registers)
- **Allocation Strategy:** Prefer caller-saved (EAX, ECX, EDX), then callee-saved
- **Tracking:** `CodeGenContext.available[]` array tracks register usage
- **Spilling:** Not implemented (exits on register exhaustion)

### Stack Frame Layout (x86-32)
```
High Address
  [EBP+12]  Parameter 2
  [EBP+8]   Parameter 1
  [EBP+4]   Return Address
  [EBP+0]   Saved EBP
  [EBP-4]   Local Variable 1
  [EBP-8]   Local Variable 2
  ...
Low Address
```

### Calling Convention
- **Parameters:** Pushed right-to-left (last parameter first)
- **Stack Cleanup:** Caller cleans stack (cdecl convention)
- **Return Value:** In EAX register
- **Callee-Saved:** EBX, ESI, EDI (saved/restored if used)

---

## Error Handling Flow

1. **Lexical Errors:** Recorded in `lexer_errors.txt`, parsing continues
2. **Syntax Errors:** Recorded in `syntax_error.txt`, parser attempts recovery
3. **Semantic Errors:** Recorded in `semantic_errors.txt`, compilation continues
4. **Code Generation:** Skipped if semantic errors exist

---

## Build Process

1. **Flex** processes `scanner.l` → generates `scanner.yy.c`
2. **Bison** processes `parser.y` → generates `parser.tab.c` and `parser.tab.h`
3. **GCC** compiles all `.c` files together:
   - `main.c`
   - `scanner.yy.c` (from Flex)
   - `parser.tab.c` (from Bison)
   - `ast.c`
   - `lexer_support.c`
   - `symbol_table.c`
   - `semantic.c`
   - `codegen.c`
4. **Linker** produces final executable: `compiler`

---

## Execution Flow Example

```
User runs: ./compiler program.src

1. main.c starts
2. Opens program.src → scanner.l reads it
3. scanner.l tokenizes → parser.y parses → AST built
4. semantic.c builds symbol tables → type checks
5. codegen.c generates:
   - codegen.ir (3-address code)
   - codegen.asm (assembly)
6. All output files written
7. Compiler exits
```

---

## Key Design Decisions

1. **Two-Pass Semantic Analysis:** Separates symbol table building from type checking
2. **AST-Based Code Generation:** Traverses AST rather than generating during parsing
3. **Register-Based Code Generation:** Uses registers for temporary values (no spilling)
4. **x86-32 Target:** Fixed architecture simplifies code generation
5. **Error Recovery:** Continues processing after errors to report all issues

---

This flow ensures a clean separation of concerns, making the compiler maintainable and extensible.

