# TMA #3 – Semantic Analysis Documentation

## Overview

This document describes the semantic analysis phase of the compiler, which performs type checking, scope resolution, and validation of program meaning. The semantic analyzer operates in two distinct passes over the Abstract Syntax Tree (AST) generated by the parser.

---

## (a) Symbol Table Data Structures

### Symbol Table Structure

The symbol table implementation (`symbol_table.h`, `symbol_table.c`) provides hierarchical scoping with the following components:

#### Symbol Structure
```c
typedef struct Symbol {
    char *name;              // Identifier name
    char *typeName;          // Type: "int", "float", "void", or class name
    SymKind kind;            // SYM_VAR, SYM_FUNC, SYM_CLASS, SYM_PARAM, SYM_ATTR
    int lineno;              // Declaration line number
    int size;                // Memory size in bytes (for code generation)
    int offset;              // Stack frame offset (for code generation)
    struct Symbol *next;      // Linked list of symbols in same scope
    struct Symbol *params;    // For functions: parameter list
} Symbol;
```

#### Symbol Table (Scope) Structure
```c
typedef struct SymTable {
    char *scopeName;         // Scope identifier (function/class name or "global")
    struct SymTable *parent; // Parent scope (for nested scoping)
    Symbol *symbols;         // Linked list of symbols in this scope
    struct SymTable *next;   // For global scope registry
    int next_offset;         // Next available stack frame offset
    int frame_size;          // Total frame size in bytes
} SymTable;
```

### Symbol Kinds
- **SYM_VAR**: Local variable
- **SYM_FUNC**: Function declaration
- **SYM_CLASS**: Class declaration
- **SYM_PARAM**: Function parameter
- **SYM_ATTR**: Class attribute

### Scope Hierarchy
- **Global scope**: Top-level declarations (classes, functions)
- **Class scope**: Attributes and methods (nested under global)
- **Function scope**: Parameters and local variables (nested under class or global)

---

## (b) Complete List of Semantic Rules

### Rule Categories

#### 1. Declaration Rules

**Rule D1: Duplicate Declaration Check**
- **Trigger**: When inserting a symbol into a symbol table
- **Action**: Check if symbol with same name exists in current scope
- **Error**: "Symbol 'X' redeclared in scope 'Y'"
- **Implementation**: `symtable_insert()` returns 1 on duplicate

**Rule D2: Class Declaration**
- **Trigger**: `NODE_CLASS_DECL` in Pass A
- **Action**: Insert class into global scope, create class scope, process class body
- **Error**: Duplicate class name
- **Implementation**: `semantic_passA_build()` case `NODE_CLASS_DECL`

**Rule D3: Function Declaration**
- **Trigger**: `NODE_FUNC_DECL` in Pass A
- **Action**: Insert function into current scope, create function scope, process parameters and body
- **Error**: Duplicate function name, duplicate parameter names
- **Implementation**: `semantic_passA_build()` case `NODE_FUNC_DECL`

**Rule D4: Parameter Declaration**
- **Trigger**: Function parameter in Pass A
- **Action**: Insert parameter into function scope, add to function's parameter list
- **Error**: Duplicate parameter name
- **Implementation**: `semantic_passA_build()` processes `NODE_PARAM` nodes

**Rule D5: Variable Declaration**
- **Trigger**: `NODE_VAR_DECL` in Pass A
- **Action**: Insert variable into current scope with type information
- **Error**: Duplicate variable name in same scope
- **Implementation**: `semantic_passA_build()` case `NODE_VAR_DECL`

**Rule D6: Attribute Declaration**
- **Trigger**: `NODE_ATTRIBUTE` in Pass A
- **Action**: Insert attribute into class scope
- **Error**: Duplicate attribute name
- **Implementation**: `semantic_passA_build()` case `NODE_ATTRIBUTE`

#### 2. Scope Resolution Rules

**Rule S1: Identifier Lookup**
- **Trigger**: `NODE_ID` in Pass B
- **Action**: Search current scope, then parent scopes (up to global)
- **Error**: "Identifier 'X' used before declaration"
- **Implementation**: `symtable_lookup()` climbs parent chain

**Rule S2: Function Call Resolution**
- **Trigger**: `NODE_FUNCTION_CALL` in Pass B
- **Action**: Lookup function name in symbol table
- **Error**: "Call to undefined function 'X'"
- **Implementation**: `resolve_type_of_expr()` case `NODE_FUNCTION_CALL`

#### 3. Type Checking Rules

**Rule T1: Literal Types**
- **Trigger**: Literal nodes in expressions
- **Action**: Return intrinsic type
  - `NODE_INT_LITERAL` → "int"
  - `NODE_FLOAT_LITERAL` → "float"
  - `NODE_STRING_LITERAL` → "string"
- **Implementation**: `resolve_type_of_expr()` literal cases

**Rule T2: Identifier Type**
- **Trigger**: `NODE_ID` in expression
- **Action**: Lookup symbol, return its `typeName`
- **Error**: Undeclared identifier
- **Implementation**: `resolve_type_of_expr()` case `NODE_ID`

**Rule T3: Arithmetic Operation Types**
- **Trigger**: Binary operators `+`, `-`, `*`, `/`
- **Action**: Both operands must be numeric (int or float)
  - If either is float, result is float
  - Otherwise result is int
- **Error**: "Arithmetic operands must be numeric (found X and Y)"
- **Implementation**: `resolve_type_of_expr()` arithmetic branch

**Rule T4: Relational Operation Types**
- **Trigger**: Binary operators `==`, `<>`, `<`, `>`, `<=`, `>=`
- **Action**: Operands must be same type or both numeric
- **Result**: Always "int" (boolean result)
- **Error**: "Incompatible types for relational operation (X, Y)"
- **Implementation**: `resolve_type_of_expr()` relational branch

**Rule T5: Logical Operation Types**
- **Trigger**: Binary operators `and`, `or`, `&&`, `||`
- **Action**: Both operands must be "int"
- **Result**: "int"
- **Error**: "Logical operands must be integers (found X and Y)"
- **Implementation**: `resolve_type_of_expr()` logical branch

**Rule T6: Unary Operation Types**
- **Trigger**: Unary operators `not`, `+`, `-`
- **Action**: 
  - `not`: Operand must be "int", result is "int"
  - `+`, `-`: Operand must be numeric, result is operand type
- **Error**: "Operand of 'not' must be integer" or "Unary X expects numeric operand"
- **Implementation**: `resolve_type_of_expr()` case `NODE_UNARY_OP`

**Rule T7: Assignment Type Compatibility**
- **Trigger**: `NODE_ASSIGN` in Pass B
- **Action**: Left and right sides must have compatible types
  - Same type: valid
  - int → float: valid (promotion)
  - Other mismatches: error
- **Error**: "Type mismatch in assignment: left is X, right is Y"
- **Implementation**: `check_assignment()`

**Rule T8: Function Call Argument Types**
- **Trigger**: `NODE_FUNCTION_CALL` in Pass B
- **Action**: Check argument count matches parameter count, argument types match parameter types
- **Error**: "Call to 'X' with wrong number of arguments" or "Argument type mismatch"
- **Implementation**: `resolve_type_of_expr()` case `NODE_FUNCTION_CALL`

**Rule T9: Return Type Checking**
- **Trigger**: `NODE_RETURN` in Pass B
- **Action**: 
  - Void function: must not return a value
  - Non-void function: return expression type must match function return type
  - int → float promotion allowed
- **Error**: "Void functions should not return a value" or "Return type mismatch"
- **Implementation**: `semantic_passB_visit()` case `NODE_RETURN`

#### 4. Control Flow Rules

**Rule C1: If Condition Type**
- **Trigger**: `NODE_IF` in Pass B
- **Action**: Condition expression must be numeric
- **Error**: "IF condition must be numeric (found X)"
- **Implementation**: `check_condition()` called for IF

**Rule C2: While Condition Type**
- **Trigger**: `NODE_WHILE` in Pass B
- **Action**: Condition expression must be numeric
- **Error**: "WHILE condition must be numeric (found X)"
- **Implementation**: `check_condition()` called for WHILE

#### 5. I/O Rules

**Rule I1: Read Statement**
- **Trigger**: `NODE_READ` in Pass B
- **Action**: Operand must be an identifier, identifier must be declared
- **Error**: "READ expects an identifier" or "READ on undeclared variable 'X'"
- **Implementation**: `semantic_passB_visit()` case `NODE_READ`

**Rule I2: Write Statement**
- **Trigger**: `NODE_WRITE` in Pass B
- **Action**: Expression type is resolved (no restriction on type)
- **Implementation**: `semantic_passB_visit()` case `NODE_WRITE`

---

## (c) Syntax-Directed Translation & AST Mapping

### AST Construction During Parsing

The parser (`parser.y`) builds the AST using syntax-directed translation. Each grammar production has semantic actions that create AST nodes:

#### Program Structure
- **`prog`** → Creates `NODE_PROGRAM` root, appends class/function/implementation nodes as children

#### Class Declarations
- **`classDecl`** → Creates `NODE_CLASS_DECL` with class name
  - `classInherit` → Creates `NODE_CLASS_INHERIT_LIST` (child of class)
  - `classBody` → Creates sibling list of `NODE_ATTRIBUTE` nodes

#### Function Declarations
- **`funcDef`** → Combines `funcHead` and `funcBody`
  - `funcHead` → Creates `NODE_FUNC_DECL` with function name and return type
    - Parameters stored as `NODE_PARAM` children (sibling list)
  - `funcBody` → Creates `NODE_FUNC_BODY`, stored in function's `extra` field
    - Contains sibling list of `NODE_VAR_DECL` and statement nodes

#### Statements
- **`assignStat`** → Creates `NODE_ASSIGN` with `NODE_ID` (lhs) and expression (rhs) as children
- **`if` statement** → Creates `NODE_IF` with condition, then-block, else-block as children
- **`while` statement** → Creates `NODE_WHILE` with condition and body as children
- **`read` statement** → Creates `NODE_READ` with `NODE_ID` as child
- **`write` statement** → Creates `NODE_WRITE` with expression as child
- **`return` statement** → Creates `NODE_RETURN` with expression as child

#### Expressions
- **Binary operations** → Creates `NODE_BINARY_OP` with operator name, left and right operands as children
- **Unary operations** → Creates `NODE_UNARY_OP` with operator name and operand as child
- **Function calls** → Creates `NODE_FUNCTION_CALL` with function name, arguments as children (sibling list)
- **Identifiers** → Creates `NODE_ID` with identifier name
- **Literals** → Creates `NODE_INT_LITERAL`, `NODE_FLOAT_LITERAL`, or `NODE_STRING_LITERAL`

### Semantic Action Mapping to AST Nodes

#### Pass A (Symbol Table Construction)

| AST Node Type | Semantic Action | Effect |
|--------------|----------------|--------|
| `NODE_CLASS_DECL` | Insert class into global scope, create class scope | Class symbol added, nested scope created |
| `NODE_FUNC_DECL` | Insert function into current scope, create function scope | Function symbol added, parameter list bound, function scope created |
| `NODE_PARAM` | Insert parameter into function scope, add to function's param list | Parameter symbol added, linked to function |
| `NODE_VAR_DECL` | Insert variable into current scope | Variable symbol added with type and offset |
| `NODE_ATTRIBUTE` | Insert attribute into class scope | Attribute symbol added to class |

**Traversal Strategy**: Depth-first traversal of AST, processing declarations as encountered.

#### Pass B (Semantic Checking)

| AST Node Type | Semantic Action | Effect |
|--------------|----------------|--------|
| `NODE_ID` | Lookup symbol in scope hierarchy | Verify identifier is declared, return type |
| `NODE_ASSIGN` | Type-check left and right sides | Verify assignment compatibility |
| `NODE_BINARY_OP` | Type-check operands, verify operation validity | Check arithmetic/relational/logical rules |
| `NODE_UNARY_OP` | Type-check operand | Verify unary operation validity |
| `NODE_FUNCTION_CALL` | Lookup function, check argument count/types | Verify function exists and call is valid |
| `NODE_RETURN` | Check return expression type matches function return type | Verify return type compatibility |
| `NODE_IF` | Type-check condition (must be numeric) | Verify condition is valid |
| `NODE_WHILE` | Type-check condition (must be numeric) | Verify condition is valid |
| `NODE_READ` | Verify operand is declared identifier | Check READ statement validity |
| `NODE_WRITE` | Resolve expression type | No restriction, just type resolution |

**Traversal Strategy**: Recursive traversal maintaining current scope context and expected return type.

---

## (d) Semantic Error Reporting

### Error Location Tracking

All semantic errors include:
- **Line number**: Source file line where error occurred
- **Error message**: Descriptive text explaining the violation

### Error Synchronization

Errors are collected during both passes but reported in a synchronized order:
- Errors are stored in an array (`errorMsgs[]`) with deduplication
- All errors are written to `semantic_errors.txt` after Pass B completes
- Errors are ordered by occurrence (line number order)

### Sample Error Outputs

#### From `tests/error01.src`:
```
Semantic Error [line 1]: Parameter 'a' duplicated in function 'add'
Semantic Error [line 3]: Local variable 'result' redeclared in function 'add'
Semantic Error [line 4]: Identifier 'b' used before declaration
Semantic Error [line 5]: Identifier 'total' used before declaration
Semantic Error [line 6]: Arithmetic operands must be numeric (found string and int)
Semantic Error [line 7]: Call to undefined function 'output'
Semantic Error [line 8]: Identifier 'total' used before declaration
```

#### From `tests/error02.src`:
```
Semantic Error [line 3]: Local variable 'total' redeclared in function 'calculate'
Semantic Error [line 4]: Identifier 'result' used before declaration
Semantic Error [line 5]: Identifier 'z' used before declaration
Semantic Error [line 5]: Identifier 'unknownVar' used before declaration
Semantic Error [line 6]: Arithmetic operands must be numeric (found string and int)
Semantic Error [line 7]: Arithmetic operands must be numeric (found float and string)
Semantic Error [line 8]: Logical operands must be integers (found int and float)
Semantic Error [line 9]: Logical operands must be integers (found string and int)
Semantic Error [line 10]: READ on undeclared variable 'inputVar'
Semantic Error [line 11]: Identifier 'outputVar' used before declaration
Semantic Error [line 12]: Arithmetic operands must be numeric (found int and string)
Semantic Error [line 13]: Arithmetic operands must be numeric (found int and string)
Semantic Error [line 14]: Arithmetic operands must be numeric (found int and string)
Semantic Error [line 15]: Logical operands must be integers (found int and string)
Semantic Error [line 16]: Call to 'calculate' with wrong number of arguments (expected 2, got 1)
Semantic Error [line 17]: Call to 'calculate' with wrong number of arguments (expected 2, got 3)
Semantic Error [line 17]: Argument type mismatch in call to 'calculate' (param y expects float, got string)
Semantic Error [line 22]: Local variable 'p' redeclared in function 'anotherFunc'
Semantic Error [line 25]: Identifier 's' used before declaration
Semantic Error [line 25]: Identifier 'unknown' used before declaration
Semantic Error [line 26]: Arithmetic operands must be numeric (found string and int)
Semantic Error [line 27]: Arithmetic operands must be numeric (found int and string)
```

### Error Categories Summary

1. **Declaration Errors**: Duplicate symbols in same scope
2. **Scope Errors**: Undeclared identifier usage
3. **Type Errors**: Type mismatches in operations, assignments, function calls
4. **Function Call Errors**: Wrong argument count, argument type mismatches
5. **Return Errors**: Return type mismatches, void function returning value
6. **Control Flow Errors**: Invalid condition types

---

## Implementation Details

### Two-Pass Architecture

**Pass A (`semantic_passA`)**:
- Traverses AST to build symbol tables
- Creates scopes for classes and functions
- Inserts all declarations
- Detects duplicate declarations

**Pass B (`semantic_passB`)**:
- Traverses AST to perform type checking
- Uses symbol tables built in Pass A
- Validates all expressions, statements, function calls
- Reports semantic violations

### Key Functions

- `semantic_passA()`: Entry point for Pass A
- `semantic_passA_build()`: Recursive builder for symbol tables
- `semantic_passB()`: Entry point for Pass B
- `semantic_passB_visit()`: Recursive visitor for type checking
- `resolve_type_of_expr()`: Type resolution for expressions
- `check_assignment()`: Assignment type checking
- `check_condition()`: Condition type checking
- `sem_error()`: Error reporting with deduplication

### Symbol Table Operations

- `symtable_create()`: Create new scope
- `symtable_insert()`: Insert symbol (returns 1 on duplicate)
- `symtable_lookup()`: Search scope hierarchy
- `symtable_add_param()`: Add parameter to function
- `symtable_find_scope()`: Find scope by name
- `symtable_print_all()`: Dump all symbol tables to file

---

## Test Results

All test programs in `tests/` directory have been validated:

- **Valid programs** (`test01.src`, `test02.src`, `test_pass.src`): No semantic errors, code generation proceeds
- **Invalid programs** (`test03.src`, `test04.src`, `error01.src`, `error02.src`): Semantic errors detected, code generation skipped

See `semantic_errors.txt` for detailed error reports from each test run.

