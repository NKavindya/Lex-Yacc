/* 
 * main.c - Main entry point for the compiler
 * 
 * This file orchestrates the entire compilation process:
 * 1. Lexical Analysis (tokenization)
 * 2. Syntax Analysis (parsing and AST construction)
 * 3. Semantic Analysis (symbol table building and type checking)
 * 4. Code Generation (IR, assembly, and machine code)
 */

#include <stdio.h>      // Standard I/O functions (printf, fprintf, fopen, etc.)
#include <stdlib.h>     // Standard library functions (malloc, free, etc.)
#include "ast.h"        // Abstract Syntax Tree data structures and functions
#include "symbol_table.h" // Symbol table management for semantic analysis
#include "lexer_support.h" // Lexical analysis support functions
#include "codegen.h"    // Code generation functions

/* External declarations from parser.y (generated by Bison) */
extern AST *astRoot;    // Root node of the Abstract Syntax Tree (set by parser)
extern int yyparse();   // Bison-generated parser function (returns 0 on success)
extern FILE *yyin;      // Input file stream for the lexer (set here, used by lexer)

/* Global file pointer for writing derivation steps during parsing */
FILE *derivation_file = NULL;  // File handle for derivation_steps.txt output

/* External declarations from semantic.c */
void semantic_passA(AST *root);      // Semantic Pass A: Build symbol tables
void semantic_passB(AST *root);      // Semantic Pass B: Type checking and validation
int semantic_error_total(void);       // Returns total count of semantic errors
extern SymTable *globalTable;        // Global symbol table (created in semantic.c)
extern FILE *errFile;                // File handle for semantic error output

/**
 * main - Compiler entry point
 * 
 * Compilation pipeline:
 * 1. Initialize lexer support structures
 * 2. Open source file and set up lexer input
 * 3. Parse source code (builds AST)
 * 4. Perform semantic analysis (build symbol tables, check types)
 * 5. Generate code (IR, assembly, machine code) if no errors
 * 
 * @param argc Number of command-line arguments
 * @param argv Command-line arguments (argv[1] should be source file path)
 * @return 0 on success, 1 on error
 */
int main(int argc, char **argv) {
    // Initialize lexer support: set up data structures for token/symbol tracking
    lex_support_init();
    
    // Check command-line arguments: require source file path
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <sourcefile>\n", argv[0]);
        return 1;
    }
    
    // Open source file for reading
    FILE *f = fopen(argv[1], "r");
    if (!f) { 
        perror("fopen");  // Print system error message
        return 1; 
    }
    yyin = f;  // Set lexer input stream to source file

    // Open file for writing derivation steps (grammar rule applications during parsing)
    derivation_file = fopen("derivation_steps.txt", "w");

    // PHASE 1: SYNTAX ANALYSIS (PARSING)
    // Invoke Bison-generated parser: tokenizes input and builds AST
    // Returns 0 on success, non-zero on syntax error
    if (yyparse() != 0) {
        fprintf(stderr, "Parsing failed.\n");
        fclose(f);
        if (derivation_file) fclose(derivation_file);
        lex_support_finalize();  // Clean up lexer data structures
        return 1;
    }
    fclose(f);  // Close source file (parsing complete)
    if (derivation_file) fflush(derivation_file);  // Ensure derivation steps are written

    // Verify AST was created successfully
    if (!astRoot) {
        fprintf(stderr, "No AST produced.\n");
        if (derivation_file) fclose(derivation_file);
        lex_support_finalize();
        return 1;
    }

    // Print AST structure to stdout for debugging/inspection
    printf("=== AST ===\n");
    ast_print(astRoot, 0);  // Print AST starting at root with 0 indentation

    // PHASE 2: SEMANTIC ANALYSIS
    // Open file for semantic error messages
    errFile = fopen("semantic_errors.txt", "w");
    if (!errFile) errFile = stdout;  // Fallback to stdout if file open fails

    // Semantic Pass A: Build symbol tables
    // Traverses AST and creates symbol table entries for:
    // - Classes, functions, variables, parameters, attributes
    // - Establishes scope hierarchy (global -> function -> block scopes)
    semantic_passA(astRoot);

    // Write symbol table to file for inspection
    FILE *symout = fopen("symbol_table.txt", "w");
    if (symout) {
        symtable_print_all(globalTable, symout);  // Print all scopes and symbols
        fclose(symout);
    }

    // Semantic Pass B: Type checking and validation
    // Checks for:
    // - Type mismatches in assignments and operations
    // - Undeclared identifiers
    // - Wrong number of function arguments
    // - Variable redeclarations
    semantic_passB(astRoot);
    int semanticErrors = semantic_error_total();  // Get total error count

    // PHASE 3: OUTPUT LEXICAL ANALYSIS ARTIFACTS
    // Write lexical symbol table (all identifiers, literals, reserved words found)
    FILE *lexsym = fopen("lexer_symbols.txt", "w");
    if (lexsym) {
        lex_support_dump_symbols(lexsym);  // Dump symbol frequency and location info
        fclose(lexsym);
    }
    
    // Write token trace (sequence of all tokens recognized during lexing)
    FILE *toklog = fopen("lexer_tokens.txt", "w");
    if (toklog) {
        lex_support_dump_tokens(toklog);  // Dump all tokens with line/column positions
        fclose(toklog);
    }
    
    // Write lexical errors (malformed tokens, unknown characters, etc.)
    FILE *lexerr = fopen("lexer_errors.txt", "w");
    if (lexerr) {
        lex_support_dump_errors(lexerr);  // Dump all lexical errors encountered
        fclose(lexerr);
    }
    
    // Clean up lexer data structures (free memory)
    lex_support_finalize();

    // PHASE 4: CODE GENERATION (only if no semantic errors)
    if (semanticErrors == 0) {
        // Generate Intermediate Representation (3-address code)
        // IR is machine-independent representation between AST and assembly
        if (codegen_generate_ir(astRoot, globalTable, "codegen.ir") == 0) {
            printf("Intermediate Representation written to codegen.ir\n");
        }
        
        // Generate x86-32 assembly code from AST
        // Uses symbol table for variable offsets and function information
        if (codegen_generate(astRoot, globalTable, "codegen.asm") == 0) {
            printf("Assembly code written to codegen.asm\n");
            
            // Generate relocatable machine code from assembly
            // Relocatable code can be loaded at any memory address
            if (codegen_generate_relocatable("codegen.asm", "codegen.reloc") == 0) {
                printf("Relocatable machine code written to codegen.reloc\n");
            }
            
            // Generate absolute machine code from assembly
            // Absolute code has fixed memory addresses
            if (codegen_generate_absolute("codegen.asm", "codegen.abs") == 0) {
                printf("Absolute machine code written to codegen.abs\n");
            }
        } else {
            fprintf(stderr, "Code generation failed.\n");
        }
    } else {
        // Skip code generation if semantic errors exist
        printf("Skipping code generation due to %d semantic error(s).\n", semanticErrors);
    }

    // Cleanup: close file handles
    if (errFile && errFile != stdout) fclose(errFile);
    if (derivation_file) fclose(derivation_file);

    // Print summary of output files generated
    printf("Done. See lexer_tokens.txt, lexer_symbols.txt, semantic_errors.txt, symbol_table.txt");
    if (semanticErrors == 0) {
        printf(", codegen.ir, codegen.asm, codegen.reloc, codegen.abs");
    }
    printf("\n");
    return 0;  // Success
}
