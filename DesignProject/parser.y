/* 
 * parser.y - parser definition (Bison grammar file)
 * 
 * this file defines the parser using Bison (GNU Yacc).
 * the parser implements an LL(1) grammar transformed from the original EBNF grammar.
 * 
 * key features:
 * 1. LL(1) grammar: transformed from EBNF by removing left recursion and EBNF notations
 * 2. AST construction: builds abstract syntax tree during parsing
 * 3. derivation logging: records grammar rule applications to derivation_steps.txt
 * 4. location tracking: tracks source line/column for error reporting
 * 
 * grammar structure:
 * - top-level: prog (program) contains classOrImplOrFunc (classes, implementations, functions)
 * - classes: classDecl with optional inheritance and member declarations
 * - implementations: implDef with function definitions
 * - functions: funcDef with parameters, return type, and body
 * - statements: if, while, assign, read, write, return, function call
 * - expressions: arithmetic and relational expressions with proper precedence
 * 
 * LL(1) transformations applied:
 * - EBNF {{ ... }} (zero or more) -> right-recursive list rules
 * - left recursion removed by converting to right recursion
 * - ambiguities resolved through precedence rules and grammar restructuring
 */

%{
/* c code section: included verbatim in generated parser */

#include <stdio.h>   // standard i/o (fprintf, FILE)
#include <stdlib.h>  // standard library (malloc, free)
#include <string.h>  // string manipulation (strdup, strcmp)
#include "ast.h"     // abstract syntax tree data structures

/* external lexer interface (from scanner.l) */
extern int yylex();              // lexer function (generated by Flex)
void yyerror(const char *s);      // error handler function
extern FILE *yyin;                // input FILE stream (set in main.c)
extern int current_line;          // current line number (from scanner.l)
extern FILE *derivation_file;     // FILE for logging derivation steps (from main.c)
extern FILE *syntax_error_file;   // FILE for syntax errors (from main.c)

/* function to log grammar rule applications for derivation tracking */
static void log_production(const char *rule);

/* global AST root node: set by parser, used by main.c */
AST *astRoot = NULL;

%}

/* enable location tracking: Bison tracks line/column for each token */
%locations

/* semantic value union: defines types for token and nonterminal values */
%union {
    int iVal;        // integer literal value
    double dVal;     // float literal value
    char *sVal;      // string value (identifiers, string literals)
    AST *node;       // AST node pointer (for nonterminals)
}

/* ========== token declarations ========== */
/* tokens with semantic value types (for accessing values in grammar rules) */

/* literal tokens with values */
%token <sVal> ID              // identifier (variable, function, class name)
%token <iVal> INT_LIT         // integer literal (value stored in ival)
%token <dVal> FLOAT_LIT       // float literal (value stored in dval)
%token <sVal> STRING_LIT      // string literal (value stored in sval)

/* reserved word tokens (no semantic value needed) */
%token CLASS IMPLEMENT FUNC CONSTRUCT ATTRIBUTE PUBLIC PRIVATE RETURN READ WRITE IF ELSE WHILE VOID SELF ISA LOCAL THEN

/* TYPE tokens */
%token INTEGER_T FLOAT_T       // TYPE keywords (integer, float)

/* punctuation and operator tokens */
%token COLON SEMICOLON COMMA DOT ASSIGN ARROW LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
%token PLUS MINUS MULT DIV AND OR NOT EQ NE LT GT LE GE

/* ========== operator precedence ========== */
/* defines precedence and associativity for operators to resolve ambiguities */
%left OR    // logical or: lowest precedence, left-associative
%left AND   // logical and: higher precedence than or, left-associative
/* note: arithmetic operators (+, -, *, /) and relational operators (==, <, >, etc.)
 * have implicit precedence based on grammar structure (term > arithExpr > relExpr) */

/* ========== parser configuration ========== */

/* expect 4 shift/reduce conflicts due to nested access patterns in lalr(1) parser */
/* these conflicts are resolved correctly by Bison's default shift action */
/* the conflicts arise from expressions like "x.y.z", array indexing "a[i][j]", and "self.field" */
%expect 4

/* ========== nonterminal TYPE declarations ========== */
/* nonterminals that produce AST nodes */
%type <node> statBlock statementList expr relExpr arithExpr arithExprPrime term termPrime factor functionCall
%type <node> prog classOrImplOrFunc classDecl classInherit moreIds classBody memberDecl funcDecl implDef implFuncs
%type <node> funcDef funcHead funcBody varDeclOrStmtList varDeclOrStmt
%type <node> localVarDecl attributeDecl varDecl arraySizes arraySize statement assignStat
%type <node> variable idnest idOrSelf indice indiceList
%type <node> fParams fParamsTailList aParams aParamsTailList type returnType

/* nonterminals that produce string values (operators) */
%type <sVal> addOp multOp sign

%%  /* start of grammar rules section */

/* ========== grammar rules ========== */
/* each rule includes:
 * 1. Comment showing original grammar and LL(1) transformation
 * 2. Grammar rule definition
 * 3. Action code that builds AST nodes
 * 4. log_production() call to record derivation step
 */

/* grammar rule: prog -> {{ classorimplorfunc }}
 * LL(1) Transformation: prog -> classOrImplOrFunc prog | epsilon
 */
prog:
      classOrImplOrFunc prog
      {
          log_production("prog -> classOrImplOrFunc prog");
          if (!astRoot) astRoot = ast_new(NODE_PROGRAM, NULL, @1.first_line);
          if ($1) ast_append_child(astRoot, $1);
      }
    | /* EMPTY */
      {
          log_production("prog -> epsilon");
          astRoot = ast_new(NODE_PROGRAM, NULL, 0);
      }
;

/* grammar rule: classorimplorfunc -> structdecl | impldef | funcdef
 * Note: structDecl is implemented as classDecl
 */
classOrImplOrFunc:
      classDecl
      {
          log_production("classOrImplOrFunc -> classDecl");
          $$ = $1;
      }
    | implDef
      {
          log_production("classOrImplOrFunc -> implDef");
          $$ = $1;
      }
    | funcDef
      {
          log_production("classOrImplOrFunc -> funcDef");
          $$ = $1;
      }
;

/* grammar rule: classdecl -> class ID [[ isa ID {{ , ID }} ]] { {{ VISIBILITY memberdecl }} } ;
 * LL(1) Transformation: classDecl -> CLASS ID classInherit { classBody } ;
 *   where classInherit -> ISA ID moreIds | epsilon
 *   and moreIds -> COMMA ID moreIds | epsilon
 *   and classBody -> visibility memberDecl classBody | epsilon
 */
classDecl:
      CLASS ID classInherit LBRACE classBody RBRACE SEMICOLON
      {
          log_production("classDecl -> CLASS id classInherit { classBody } ;");
          AST *c = ast_new(NODE_CLASS_DECL, $2, @2.first_line);
          if ($3) ast_append_child(c, $3);
          if ($5) ast_append_child(c, $5);
          $$ = c;
      }
;

/* helper rule for: [[ isa ID {{ , ID }} ]]
 * Grammar: Optional inheritance list
 */
classInherit:
      ISA ID moreIds
      {
          log_production("classInherit -> ISA id moreIds");
          AST *list = ast_new(NODE_CLASS_INHERIT_LIST, NULL, @2.first_line);
          AST *idnode = ast_new(NODE_ID, $2, @2.first_line);
          ast_append_child(list, idnode);
          if ($3) ast_append_child(list, $3);
          $$ = list;
      }
    | /* EMPTY */
      {
          log_production("classInherit -> epsilon");
          $$ = NULL;
      }
;

/* helper rule for: {{ , ID }} in inheritance
 * Grammar: Zero or more comma-separated parent class IDs
 */
moreIds:
      COMMA ID moreIds
      {
          log_production("moreIds -> , id moreIds");
          AST *idn = ast_new(NODE_ID, $2, @2.first_line);
          if ($3) ast_append_child(idn, $3);
          $$ = idn;
      }
    | /* EMPTY */
      {
          log_production("moreIds -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: {{{ VISIBILITY memberdecl }}}
 * LL(1) Transformation: classBody -> visibility memberDecl classBody | epsilon
 */
classBody:
      PUBLIC memberDecl classBody
      {
          log_production("classBody -> PUBLIC memberDecl classBody");
          AST *vis = ast_new(NODE_VISIBILITY, "public", @1.first_line);
          if ($2) ast_append_child(vis, $2);
          if ($3) ast_append_sibling(&vis, $3);
          $$ = vis;
      }
    | PRIVATE memberDecl classBody
      {
          log_production("classBody -> PRIVATE memberDecl classBody");
          AST *vis = ast_new(NODE_VISIBILITY, "private", @1.first_line);
          if ($2) ast_append_child(vis, $2);
          if ($3) ast_append_sibling(&vis, $3);
          $$ = vis;
      }
    | /* EMPTY */
      {
          log_production("classBody -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: memberdecl -> funcdecl | attributedecl */
memberDecl:
      funcDecl
      {
          log_production("memberDecl -> funcDecl");
          $$ = $1;
      }
    | attributeDecl
      {
          log_production("memberDecl -> attributeDecl");
          $$ = $1;
      }
;

/* grammar rule: funcdecl -> funchead ; */
funcDecl:
      funcHead SEMICOLON
      {
          log_production("funcDecl -> funcHead ;");
          $$ = $1;
      }
;

/* grammar rule: impldef -> implement ID { {{funcdef}} }
 * LL(1) Transformation: implDef -> IMPLEMENT ID { implFuncs }
 *   where implFuncs -> funcDef implFuncs | epsilon
 */
implDef:
      IMPLEMENT ID LBRACE implFuncs RBRACE
      {
          log_production("implDef -> IMPLEMENT id { implFuncs }");
          AST *n = ast_new(NODE_EMPTY, $2, @2.first_line);
          if ($4) n->child = $4;
          $$ = n;
      }
;

/* helper rule for: {{funcdef}} in impldef
 * Grammar: Zero or more function definitions
 */
implFuncs:
      funcDef implFuncs
      {
          log_production("implFuncs -> funcDef implFuncs");
          $$ = $1;
          if ($2) ast_append_sibling(&$$, $2);
      }
    | /* EMPTY */
      {
          log_production("implFuncs -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: funcdef -> funchead funcbody */
funcDef:
      funcHead funcBody
      {
          log_production("funcDef -> funcHead funcBody");
          AST *f = $1;
          if ($2) f->extra = $2;
          $$ = f;
      }
;

/* grammar rule: funchead -> func ID ( fparams ) => returntype | constructor ( fparams ) */
funcHead:
      FUNC ID LPAREN fParams RPAREN ARROW returnType
      {
          log_production("funcHead -> FUNC id ( fParams ) ARROW returnType");
          AST *fn = ast_new(NODE_FUNC_DECL, $2, @2.first_line);
          if ($7) {
              fn->typeName = $7->name ? strdup($7->name) : NULL;
              ast_free($7);
          }
          if ($4) fn->child = $4;
          $$ = fn;
      }
    | CONSTRUCT LPAREN fParams RPAREN
      {
          log_production("funcHead -> CONSTRUCT ( fParams )");
          AST *fn = ast_new(NODE_FUNC_DECL, "constructor", @1.first_line);
          if ($3) fn->child = $3;
          $$ = fn;
      }
;

/* grammar rule: funcbody -> { {{vardeclorstmt}} }
 * LL(1) Transformation: funcBody -> { varDeclOrStmtList }
 *   where varDeclOrStmtList -> varDeclOrStmt varDeclOrStmtList | epsilon
 */
funcBody:
      LBRACE varDeclOrStmtList RBRACE
      {
          log_production("funcBody -> { varDeclOrStmtList }");
          AST *b = ast_new(NODE_FUNC_BODY, NULL, @1.first_line);
          if ($2) b->child = $2;
          $$ = b;
      }
;

/* helper rule for: {{vardeclorstmt}} in funcbody
 * Grammar: Zero or more variable declarations or statements
 */
varDeclOrStmtList:
      varDeclOrStmt varDeclOrStmtList
      {
          log_production("varDeclOrStmtList -> varDeclOrStmt varDeclOrStmtList");
          AST *head = $1;
          if ($2) ast_append_sibling(&head, $2);
          $$ = head;
      }
    | /* EMPTY */
      {
          log_production("varDeclOrStmtList -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: localvardeclorstmt -> localvardecl | statement */
varDeclOrStmt:
      localVarDecl
      {
          log_production("varDeclOrStmt -> localVarDecl");
          $$ = $1;
      }
    | statement
      {
          log_production("varDeclOrStmt -> statement");
          $$ = $1;
      }
;

/* grammar rule: localvardecl -> local vardecl */
localVarDecl:
      LOCAL varDecl
      {
          log_production("localVarDecl -> LOCAL varDecl");
          $$ = $2;
      }
;

/* grammar rule: attributedecl -> attribute vardecl */
attributeDecl:
      ATTRIBUTE varDecl
      {
          log_production("attributeDecl -> ATTRIBUTE varDecl");
          AST *attr = ast_new(NODE_ATTRIBUTE, NULL, @1.first_line);
          if ($2) ast_append_child(attr, $2);
          $$ = attr;
      }
;

/* grammar rule: vardecl -> ID : TYPE {{arraysize}} ;
 * LL(1) Transformation: varDecl -> ID : type arraySizes ;
 *   where arraySizes -> arraySize arraySizes | epsilon
 */
varDecl:
      ID COLON type arraySizes SEMICOLON
      {
          log_production("varDecl -> id : type arraySizes ;");
          AST *v = ast_new(NODE_VAR_DECL, $1, @1.first_line);
          if ($3) {
              v->typeName = $3->name ? strdup($3->name) : NULL;
              ast_free($3);
          }
          if ($4) v->child = $4;
          $$ = v;
      }
;

/* helper rule for: {{arraysize}} in vardecl
 * Grammar: Zero or more array size specifications
 */
arraySizes:
      arraySize arraySizes
      {
          log_production("arraySizes -> arraySize arraySizes");
          AST *head = $1;
          if ($2) ast_append_sibling(&head, $2);
          $$ = head;
      }
    | /* EMPTY */
      {
          log_production("arraySizes -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: arraysize -> [ intlit ] | [ ] */
arraySize:
      LBRACKET INT_LIT RBRACKET
      {
          log_production("arraySize -> [ INT ]");
          AST *dim = ast_new(NODE_BINARY_OP, "[]", @1.first_line);
          ast_append_child(dim, ast_new_int($2, @2.first_line));
          $$ = dim;
      }
    | LBRACKET RBRACKET
      {
          log_production("arraySize -> [ ]");
          $$ = ast_new(NODE_BINARY_OP, "[]", @1.first_line);
      }
;

/* grammar rule: statement -> assignstat ; | IF ( relexpr ) then statblock else statblock ;
 *   | while ( relExpr ) statBlock ; | read ( variable ) ; | write ( expr ) ;
 *   | return ( expr ) ; | functionCall ;
 */
statement:
      assignStat SEMICOLON
      {
          log_production("statement -> assignStat ;");
          $$ = $1;
      }
    | IF LPAREN expr RPAREN THEN statBlock ELSE statBlock SEMICOLON
      {
          log_production("statement -> IF ( expr ) THEN statBlock ELSE statBlock ;");
          AST *node = ast_new(NODE_IF, NULL, @1.first_line);
          ast_append_child(node, $3);
          ast_append_child(node, $6);
          ast_append_child(node, $8);
          $$ = node;
      }
    | WHILE LPAREN expr RPAREN statBlock SEMICOLON
      {
          log_production("statement -> WHILE ( expr ) statBlock ;");
          AST *node = ast_new(NODE_WHILE, NULL, @1.first_line);
          ast_append_child(node, $3);
          ast_append_child(node, $5);
          $$ = node;
      }
    | READ LPAREN variable RPAREN SEMICOLON
      {
          log_production("statement -> READ ( variable ) ;");
          AST *n = ast_new(NODE_READ, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | WRITE LPAREN expr RPAREN SEMICOLON
      {
          log_production("statement -> WRITE ( expr ) ;");
          AST *n = ast_new(NODE_WRITE, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | RETURN LPAREN expr RPAREN SEMICOLON
      {
          log_production("statement -> RETURN ( expr ) ;");
          AST *n = ast_new(NODE_RETURN, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | functionCall SEMICOLON
      {
          log_production("statement -> functionCall ;");
          $$ = $1;
      }
    | error SEMICOLON
      {
          log_production("statement -> error ;");
          yyerror("Recovering from statement error");
          yyerrok;
          $$ = NULL;
      }
;

/* grammar rule: assignstat -> variable assignop expr */
assignStat:
      variable ASSIGN expr
      {
          log_production("assignStat -> variable ASSIGN expr");
          AST *assign = ast_new(NODE_ASSIGN, NULL, @1.first_line);
          ast_append_child(assign, $1);
          ast_append_child(assign, $3);
          $$ = assign;
      }
;

/* helper rule for: {{statement}} in statblock
 * Grammar: Zero or more statements
 */
statementList:
      statement statementList
      {
          log_production("statementList -> statement statementList");
          AST *h = $1;
          if ($2) ast_append_sibling(&h, $2);
          $$ = h;
      }
    | /* EMPTY */
      {
          log_production("statementList -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: statblock -> { {{statement}} } | statement | ϵ
 * LL(1) Transformation: statBlock -> { statementList } | statement | epsilon
 */
statBlock:
      LBRACE statementList RBRACE
      {
          log_production("statBlock -> { statementList }");
          $$ = $2;
      }
    | statement
      {
          log_production("statBlock -> statement");
          $$ = $1;
      }
    | /* EMPTY */
      {
          log_production("statBlock -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: expr -> arithexpr | relexpr */
expr:
      arithExpr
      {
          log_production("expr -> arithExpr");
          $$ = $1;
      }
    | relExpr
      {
          log_production("expr -> relExpr");
          $$ = $1;
      }
;

/* grammar rule: relexpr -> arithexpr relop arithexpr */
relExpr:
      arithExpr EQ arithExpr
      {
          log_production("relExpr -> arithExpr == arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "==", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr NE arithExpr
      {
          log_production("relExpr -> arithExpr <> arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<>", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr LT arithExpr
      {
          log_production("relExpr -> arithExpr < arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr GT arithExpr
      {
          log_production("relExpr -> arithExpr > arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, ">", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr LE arithExpr
      {
          log_production("relExpr -> arithExpr <= arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<=", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr GE arithExpr
      {
          log_production("relExpr -> arithExpr >= arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, ">=", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
;

/* grammar rule: arithexpr -> arithexpr addop term | term
 * LL(1) Transformation: arithExpr -> term arithExprPrime
 *   where arithExprPrime -> addOp term arithExprPrime | epsilon
 */
arithExpr:
      term arithExprPrime
      {
          log_production("arithExpr -> term arithExprPrime");
          if ($2) {
              AST *op = $2;
              AST *left = $1;
              AST *right = op->child;
              op->child = left;
              if (right) {
                  op->child->sibling = right;
              }
              $$ = op;
          } else {
              $$ = $1;
          }
      }
;

/* helper rule for right-recursive arithexpr
 * Eliminates left recursion: arithExpr -> arithExpr addOp term
 */
arithExprPrime:
      addOp term arithExprPrime
      {
          log_production("arithExprPrime -> addOp term arithExprPrime");
          AST *op = ast_new(NODE_BINARY_OP, $1, @1.first_line);
          op->child = $2;  /* right operand (term) */
          if ($3) {
              AST *chain = $3;
              chain->child->sibling = op;
              $$ = chain;
          } else {
              $$ = op;
          }
          free($1);
      }
    | /* EMPTY */
      {
          log_production("arithExprPrime -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: addop -> + | - | or */
addOp:
      PLUS
      {
          log_production("addOp -> +");
          $$ = strdup("+");
      }
    | MINUS
      {
          log_production("addOp -> -");
          $$ = strdup("-");
      }
    | OR
      {
          log_production("addOp -> or");
          $$ = strdup("or");
      }
;

/* grammar rule: term -> term multop factor | factor
 * LL(1) Transformation: term -> factor termPrime
 *   where termPrime -> multOp factor termPrime | epsilon
 */
term:
      factor termPrime
      {
          log_production("term -> factor termPrime");
          if ($2) {
              AST *op = $2;
              AST *left = $1;
              AST *right = op->child;
              op->child = left;
              if (right) {
                  op->child->sibling = right;
              }
              $$ = op;
          } else {
              $$ = $1;
          }
      }
;

/* helper rule for right-recursive term
 * Eliminates left recursion: term -> term multOp factor
 */
termPrime:
      multOp factor termPrime
      {
          log_production("termPrime -> multOp factor termPrime");
          AST *op = ast_new(NODE_BINARY_OP, $1, @1.first_line);
          op->child = $2;  /* right operand (factor) */
          if ($3) {
              AST *chain = $3;
              chain->child->sibling = op;
              $$ = chain;
          } else {
              $$ = op;
          }
          free($1);
      }
    | /* EMPTY */
      {
          log_production("termPrime -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: multop -> * | / | and */
multOp:
      MULT
      {
          log_production("multOp -> *");
          $$ = strdup("*");
      }
    | DIV
      {
          log_production("multOp -> /");
          $$ = strdup("/");
      }
    | AND
      {
          log_production("multOp -> and");
          $$ = strdup("and");
      }
;

/* grammar rule: factor -> variable | functioncall | intlit | floatlit | ( arithexpr ) | not factor | sign factor */
factor:
      variable
      {
          log_production("factor -> variable");
          $$ = $1;
      }
    | functionCall
      {
          log_production("factor -> functionCall");
          $$ = $1;
      }
    | INT_LIT
      {
          log_production("factor -> INT_LIT");
          AST *n = ast_new(NODE_INT_LITERAL, NULL, @1.first_line);
          n->intValue = $1;
          $$ = n;
      }
    | FLOAT_LIT
      {
          log_production("factor -> FLOAT_LIT");
          AST *n = ast_new(NODE_FLOAT_LITERAL, NULL, @1.first_line);
          n->floatValue = $1;
          $$ = n;
      }
    | LPAREN arithExpr RPAREN
      {
          log_production("factor -> ( arithExpr )");
          $$ = $2;
      }
    | NOT factor
      {
          log_production("factor -> NOT factor");
          AST *n = ast_new(NODE_UNARY_OP, "not", @1.first_line);
          ast_append_child(n, $2);
          $$ = n;
      }
    | sign factor
      {
          log_production("factor -> sign factor");
          AST *n = ast_new(NODE_UNARY_OP, $1, @1.first_line);
          ast_append_child(n, $2);
          free($1);
          $$ = n;
      }
;

/* grammar rule: sign -> + | - */
sign:
      PLUS
      {
          log_production("sign -> +");
          $$ = strdup("+");
      }
    | MINUS
      {
          log_production("sign -> -");
          $$ = strdup("-");
      }
;

/* grammar rule: functioncall -> {{idnest}} ID ( aparams )
 * LL(1) Transformation: functionCall -> idnest DOT functionCall | ID ( aParams )
 */
functionCall:
      ID LPAREN aParams RPAREN
      {
          log_production("functionCall -> id ( aParams )");
          AST *c = ast_new(NODE_FUNCTION_CALL, $1, @1.first_line);
          if ($3) c->child = $3;
          $$ = c;
      }
    | idnest DOT functionCall
      {
          log_production("functionCall -> idnest . functionCall");
          AST *c = $3;
          if ($1) {
              if (c->child) {
                  AST *last = $1;
                  while (last->sibling) last = last->sibling;
                  last->sibling = c->child;
                  c->child = $1;
              } else {
                  c->child = $1;
              }
          }
          $$ = c;
      }
;

/* grammar rule: variable -> {{idnest}} ID {{indice}}
 * LL(1) Transformation: variable -> idOrSelf DOT ID indiceList | idnest DOT variable | ID indiceList
 *   where indiceList -> indice indiceList | epsilon
 *   Note: idOrSelf DOT ID handles base cases like self.field or obj.field (non-recursive)
 */
variable:
      ID indiceList
      {
          log_production("variable -> id indiceList");
          AST *var = ast_new(NODE_ID, $1, @1.first_line);
          if ($2) var->sibling = $2;
          $$ = var;
      }
    | idOrSelf DOT ID indiceList
      {
          log_production("variable -> idOrSelf . id indiceList");
          AST *var = ast_new(NODE_ID, $3, @3.first_line);
          if ($4) var->sibling = $4;
          if ($1) {
              AST *last = $1;
              while (last->sibling) last = last->sibling;
              last->sibling = var;
              var = $1;
          }
          $$ = var;
      }
    | idnest DOT variable
      {
          log_production("variable -> idnest . variable");
          AST *var = $3;
          if ($1) {
              AST *last = $1;
              while (last->sibling) last = last->sibling;
              last->sibling = var;
              var = $1;
          }
          $$ = var;
      }
;



/* grammar rule: idnest -> idorself {{indice}}. | idorself ( aparams ) .
 * LL(1) Transformation: idnest -> idOrSelf indiceList DOT | idOrSelf ( aParams ) DOT
 */
idnest:
      idOrSelf indiceList DOT
      {
          log_production("idnest -> idOrSelf indiceList .");
          AST *n = $1;
          if ($2) {
              if (n->sibling) {
                  AST *last = n;
                  while (last->sibling) last = last->sibling;
                  last->sibling = $2;
              } else {
                  n->sibling = $2;
              }
          }
          $$ = n;
      }
    | idOrSelf LPAREN aParams RPAREN DOT
      {
          log_production("idnest -> idOrSelf ( aParams ) .");
          AST *call = ast_new(NODE_FUNCTION_CALL, $1->name, @1.first_line);
          call->child = $3;
          $$ = call;
      }
;

/* grammar rule: idorself -> ID | self */
idOrSelf:
      ID
      {
          log_production("idOrSelf -> id");
          $$ = ast_new(NODE_ID, $1, @1.first_line);
      }
    | SELF
      {
          log_production("idOrSelf -> self");
          $$ = ast_new(NODE_ID, "self", @1.first_line);
      }
;

/* helper rule for: {{indice}} in variable and idnest
 * Grammar: Zero or more array indices
 */
indiceList:
      indice indiceList
      {
          log_production("indiceList -> indice indiceList");
          AST *head = $1;
          if ($2) ast_append_sibling(&head, $2);
          $$ = head;
      }
    | /* EMPTY */
      {
          log_production("indiceList -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: indice -> [ arithexpr ] */
indice:
      LBRACKET arithExpr RBRACKET
      {
          log_production("indice -> [ arithExpr ]");
          AST *idx = ast_new(NODE_BINARY_OP, "[]", @1.first_line);
          ast_append_child(idx, $2);
          $$ = idx;
      }
;

/* grammar rule: fparams -> ID : TYPE {{arraysize}} {{fparamstail}} | ϵ
 * LL(1) Transformation: fParams -> ID : type arraySizes fParamsTailList | epsilon
 *   where fParamsTailList -> COMMA ID : type arraySizes fParamsTailList | epsilon
 */
fParams:
      ID COLON type arraySizes fParamsTailList
      {
          log_production("fParams -> id : type arraySizes fParamsTailList");
          AST *p = ast_new(NODE_PARAM, $1, @1.first_line);
          if ($3) {
              p->typeName = $3->name ? strdup($3->name) : NULL;
              ast_free($3);
          }
          if ($4) p->child = $4;
          if ($5) ast_append_sibling(&p, $5);
          $$ = p;
      }
    | /* EMPTY */
      {
          log_production("fParams -> epsilon");
          $$ = NULL;
      }
;

/* helper rule for: {{fparamstail}} in fparams
 * Grammar Rule: fParamsTail -> , id : type {{arraySize}}
 */
fParamsTailList:
      COMMA ID COLON type arraySizes fParamsTailList
      {
          log_production("fParamsTailList -> , id : type arraySizes fParamsTailList");
          AST *p = ast_new(NODE_PARAM, $2, @2.first_line);
          if ($4) {
              p->typeName = $4->name ? strdup($4->name) : NULL;
              ast_free($4);
          }
          if ($5) p->child = $5;
          if ($6) ast_append_sibling(&p, $6);
          $$ = p;
      }
    | /* EMPTY */
      {
          log_production("fParamsTailList -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: aparams -> expr {{aparamstail}} | ϵ
 * LL(1) Transformation: aParams -> expr aParamsTailList | epsilon
 *   where aParamsTailList -> COMMA expr aParamsTailList | epsilon
 */
aParams:
      expr aParamsTailList
      {
          log_production("aParams -> expr aParamsTailList");
          AST *h = $1;
          if ($2) ast_append_sibling(&h, $2);
          $$ = h;
      }
    | /* EMPTY */
      {
          log_production("aParams -> epsilon");
          $$ = NULL;
      }
;

/* helper rule for: {{aparamstail}} in aparams
 * Grammar Rule: aParamsTail -> , expr
 */
aParamsTailList:
      COMMA expr aParamsTailList
      {
          log_production("aParamsTailList -> , expr aParamsTailList");
          AST *n = $2;
          if ($3) ast_append_sibling(&n, $3);
          $$ = n;
      }
    | /* EMPTY */
      {
          log_production("aParamsTailList -> epsilon");
          $$ = NULL;
      }
;

/* grammar rule: TYPE -> integer | float | ID */
type:
      INTEGER_T
      {
          log_production("type -> INTEGER");
          AST *t = ast_new(NODE_TYPE, "int", @1.first_line);
          $$ = t;
      }
    | FLOAT_T
      {
          log_production("type -> FLOAT");
          AST *t = ast_new(NODE_TYPE, "float", @1.first_line);
          $$ = t;
      }
    | ID
      {
          log_production("type -> id");
          AST *t = ast_new(NODE_TYPE, $1, @1.first_line);
          $$ = t;
      }
;

/* grammar rule: returntype -> TYPE | void */
returnType:
      type
      {
          log_production("returnType -> type");
          $$ = $1;
      }
    | VOID
      {
          log_production("returnType -> VOID");
          AST *t = ast_new(NODE_TYPE, "void", @1.first_line);
          $$ = t;
      }
;

%%

static void log_production(const char *rule) {
    if (derivation_file && rule) {
        fprintf(derivation_file, "%s\n", rule);
        fflush(derivation_file);
    }
}

void yyerror(const char *s) {
    fprintf(stderr, "Syntax error at line %d: %s\n", current_line, s);
    if (syntax_error_file) {
        fprintf(syntax_error_file, "Syntax error at line %d: %s\n", current_line, s);
        fflush(syntax_error_file);
    }
}
