/* 
 * parser.y - Parser Definition (Bison Grammar File)
 * 
 * This file defines the parser using Bison (GNU Yacc).
 * The parser implements an LL(1) grammar transformed from the original EBNF grammar.
 * 
 * Key Features:
 * 1. LL(1) Grammar: Transformed from EBNF by removing left recursion and EBNF notations
 * 2. AST Construction: Builds Abstract Syntax Tree during parsing
 * 3. Derivation Logging: Records grammar rule applications to derivation_steps.txt
 * 4. Location Tracking: Tracks source line/column for error reporting
 * 
 * Grammar Structure:
 * - Top-level: prog (program) contains classOrImplOrFunc (classes, implementations, functions)
 * - Classes: classDecl with optional inheritance and member declarations
 * - Implementations: implDef with function definitions
 * - Functions: funcDef with parameters, return type, and body
 * - Statements: if, while, assign, read, write, return, function call
 * - Expressions: arithmetic and relational expressions with proper precedence
 * 
 * LL(1) Transformations Applied:
 * - EBNF {{ ... }} (zero or more) -> right-recursive list rules
 * - Left recursion removed by converting to right recursion
 * - Ambiguities resolved through precedence rules and grammar restructuring
 */

%{
/* C code section: included verbatim in generated parser */

#include <stdio.h>   // Standard I/O (fprintf, FILE)
#include <stdlib.h>  // Standard library (malloc, free)
#include <string.h>  // String manipulation (strdup, strcmp)
#include "ast.h"     // Abstract Syntax Tree data structures

/* External lexer interface (from scanner.l) */
extern int yylex();              // Lexer function (generated by Flex)
void yyerror(const char *s);      // Error handler function
extern FILE *yyin;                // Input file stream (set in main.c)
extern int current_line;          // Current line number (from scanner.l)
extern FILE *derivation_file;     // File for logging derivation steps (from main.c)

/* Function to log grammar rule applications for derivation tracking */
static void log_production(const char *rule);

/* Global AST root node: set by parser, used by main.c */
AST *astRoot = NULL;

%}

/* Enable location tracking: Bison tracks line/column for each token */
%locations

/* Semantic value union: defines types for token and nonterminal values */
%union {
    int iVal;        // Integer literal value
    double dVal;     // Float literal value
    char *sVal;      // String value (identifiers, string literals)
    AST *node;       // AST node pointer (for nonterminals)
}

/* ========== Token Declarations ========== */
/* Tokens with semantic value types (for accessing values in grammar rules) */

/* Literal tokens with values */
%token <sVal> ID              // Identifier (variable, function, class name)
%token <iVal> INT_LIT         // Integer literal (value stored in iVal)
%token <dVal> FLOAT_LIT       // Float literal (value stored in dVal)
%token <sVal> STRING_LIT      // String literal (value stored in sVal)

/* Reserved word tokens (no semantic value needed) */
%token CLASS IMPLEMENT FUNC CONSTRUCT ATTRIBUTE PUBLIC PRIVATE RETURN READ WRITE IF ELSE WHILE VOID SELF ISA LOCAL THEN

/* Type tokens */
%token INTEGER_T FLOAT_T       // Type keywords (integer, float)

/* Punctuation and operator tokens */
%token COLON SEMICOLON COMMA DOT ASSIGN ARROW LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
%token PLUS MINUS MULT DIV AND OR NOT EQ NE LT GT LE GE

/* ========== Operator Precedence ========== */
/* Defines precedence and associativity for operators to resolve ambiguities */
%left OR    // Logical OR: lowest precedence, left-associative
%left AND   // Logical AND: higher precedence than OR, left-associative
/* Note: Arithmetic operators (+, -, *, /) and relational operators (==, <, >, etc.)
 * have implicit precedence based on grammar structure (term > arithExpr > relExpr) */

/* ========== Parser Configuration ========== */

/* Expect 4 shift/reduce conflicts due to nested access patterns in LALR(1) parser */
/* These conflicts are resolved correctly by Bison's default shift action */
/* The conflicts arise from expressions like "x.y.z", array indexing "a[i][j]", and "self.field" */
%expect 4

/* ========== Nonterminal Type Declarations ========== */
/* Nonterminals that produce AST nodes */
%type <node> statBlock statementList expr relExpr arithExpr arithExprPrime term termPrime factor functionCall
%type <node> prog classOrImplOrFunc classDecl classInherit moreIds classBody memberDecl funcDecl implDef implFuncs
%type <node> funcDef funcHead funcBody varDeclOrStmtList varDeclOrStmt
%type <node> localVarDecl attributeDecl varDecl arraySizes arraySize statement assignStat
%type <node> variable idnest idOrSelf indice indiceList
%type <node> fParams fParamsTailList aParams aParamsTailList type returnType

/* Nonterminals that produce string values (operators) */
%type <sVal> addOp multOp sign

%%  /* Start of grammar rules section */

/* ========== Grammar Rules ========== */
/* Each rule includes:
 * 1. Comment showing original grammar and LL(1) transformation
 * 2. Grammar rule definition
 * 3. Action code that builds AST nodes
 * 4. log_production() call to record derivation step
 */

/* Grammar Rule: prog -> {{ classOrImplOrFunc }}
 * LL(1) Transformation: prog -> classOrImplOrFunc prog | epsilon
 */
prog:
      classOrImplOrFunc prog
      {
          log_production("prog -> classOrImplOrFunc prog");
          if (!astRoot) astRoot = ast_new(NODE_PROGRAM, NULL, @1.first_line);
          if ($1) ast_append_child(astRoot, $1);
      }
    | /* empty */
      {
          log_production("prog -> epsilon");
          astRoot = ast_new(NODE_PROGRAM, NULL, 0);
      }
;

/* Grammar Rule: classOrImplOrFunc -> structDecl | implDef | funcDef
 * Note: structDecl is implemented as classDecl
 */
classOrImplOrFunc:
      classDecl
      {
          log_production("classOrImplOrFunc -> classDecl");
          $$ = $1;
      }
    | implDef
      {
          log_production("classOrImplOrFunc -> implDef");
          $$ = $1;
      }
    | funcDef
      {
          log_production("classOrImplOrFunc -> funcDef");
          $$ = $1;
      }
;

/* Grammar Rule: classDecl -> class id [[ isa id {{ , id }} ]] { {{ visibility memberDecl }} } ;
 * LL(1) Transformation: classDecl -> CLASS ID classInherit { classBody } ;
 *   where classInherit -> ISA ID moreIds | epsilon
 *   and moreIds -> COMMA ID moreIds | epsilon
 *   and classBody -> visibility memberDecl classBody | epsilon
 */
classDecl:
      CLASS ID classInherit LBRACE classBody RBRACE SEMICOLON
      {
          log_production("classDecl -> CLASS id classInherit { classBody } ;");
          AST *c = ast_new(NODE_CLASS_DECL, $2, @2.first_line);
          if ($3) ast_append_child(c, $3);
          if ($5) ast_append_child(c, $5);
          $$ = c;
      }
;

/* Helper rule for: [[ isa id {{ , id }} ]]
 * Grammar: Optional inheritance list
 */
classInherit:
      ISA ID moreIds
      {
          log_production("classInherit -> ISA id moreIds");
          AST *list = ast_new(NODE_CLASS_INHERIT_LIST, NULL, @2.first_line);
          AST *idnode = ast_new(NODE_ID, $2, @2.first_line);
          ast_append_child(list, idnode);
          if ($3) ast_append_child(list, $3);
          $$ = list;
      }
    | /* empty */
      {
          log_production("classInherit -> epsilon");
          $$ = NULL;
      }
;

/* Helper rule for: {{ , id }} in inheritance
 * Grammar: Zero or more comma-separated parent class IDs
 */
moreIds:
      COMMA ID moreIds
      {
          log_production("moreIds -> , id moreIds");
          AST *idn = ast_new(NODE_ID, $2, @2.first_line);
          if ($3) ast_append_child(idn, $3);
          $$ = idn;
      }
    | /* empty */
      {
          log_production("moreIds -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: {{{ visibility memberDecl }}}
 * LL(1) Transformation: classBody -> visibility memberDecl classBody | epsilon
 */
classBody:
      PUBLIC memberDecl classBody
      {
          log_production("classBody -> PUBLIC memberDecl classBody");
          if ($2) {
              if ($2->typeName) free($2->typeName);
              $2->typeName = strdup("public");
          }
          if ($3) ast_append_sibling(&$2, $3);
          $$ = $2;
      }
    | PRIVATE memberDecl classBody
      {
          log_production("classBody -> PRIVATE memberDecl classBody");
          if ($2) {
              if ($2->typeName) free($2->typeName);
              $2->typeName = strdup("private");
          }
          if ($3) ast_append_sibling(&$2, $3);
          $$ = $2;
      }
    | /* empty */
      {
          log_production("classBody -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: memberDecl -> funcDecl | attributeDecl */
memberDecl:
      funcDecl
      {
          log_production("memberDecl -> funcDecl");
          $$ = $1;
      }
    | attributeDecl
      {
          log_production("memberDecl -> attributeDecl");
          $$ = $1;
      }
;

/* Grammar Rule: funcDecl -> funcHead ; */
funcDecl:
      funcHead SEMICOLON
      {
          log_production("funcDecl -> funcHead ;");
          $$ = $1;
      }
;

/* Grammar Rule: implDef -> implement id { {{funcDef}} }
 * LL(1) Transformation: implDef -> IMPLEMENT ID { implFuncs }
 *   where implFuncs -> funcDef implFuncs | epsilon
 */
implDef:
      IMPLEMENT ID LBRACE implFuncs RBRACE
      {
          log_production("implDef -> IMPLEMENT id { implFuncs }");
          AST *n = ast_new(NODE_EMPTY, $2, @2.first_line);
          if ($4) n->child = $4;
          $$ = n;
      }
;

/* Helper rule for: {{funcDef}} in implDef
 * Grammar: Zero or more function definitions
 */
implFuncs:
      funcDef implFuncs
      {
          log_production("implFuncs -> funcDef implFuncs");
          $$ = $1;
          if ($2) ast_append_sibling(&$$, $2);
      }
    | /* empty */
      {
          log_production("implFuncs -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: funcDef -> funcHead funcBody */
funcDef:
      funcHead funcBody
      {
          log_production("funcDef -> funcHead funcBody");
          AST *f = $1;
          if ($2) f->extra = $2;
          $$ = f;
      }
;

/* Grammar Rule: funcHead -> func id ( fParams ) => returnType | constructor ( fParams ) */
funcHead:
      FUNC ID LPAREN fParams RPAREN ARROW returnType
      {
          log_production("funcHead -> FUNC id ( fParams ) ARROW returnType");
          AST *fn = ast_new(NODE_FUNC_DECL, $2, @2.first_line);
          if ($7) {
              fn->typeName = $7->name ? strdup($7->name) : NULL;
              ast_free($7);
          }
          if ($4) fn->child = $4;
          $$ = fn;
      }
    | CONSTRUCT LPAREN fParams RPAREN
      {
          log_production("funcHead -> CONSTRUCT ( fParams )");
          AST *fn = ast_new(NODE_FUNC_DECL, "constructor", @1.first_line);
          if ($3) fn->child = $3;
          $$ = fn;
      }
;

/* Grammar Rule: funcBody -> { {{varDeclOrStmt}} }
 * LL(1) Transformation: funcBody -> { varDeclOrStmtList }
 *   where varDeclOrStmtList -> varDeclOrStmt varDeclOrStmtList | epsilon
 */
funcBody:
      LBRACE varDeclOrStmtList RBRACE
      {
          log_production("funcBody -> { varDeclOrStmtList }");
          AST *b = ast_new(NODE_FUNC_BODY, NULL, @1.first_line);
          if ($2) b->child = $2;
          $$ = b;
      }
;

/* Helper rule for: {{varDeclOrStmt}} in funcBody
 * Grammar: Zero or more variable declarations or statements
 */
varDeclOrStmtList:
      varDeclOrStmt varDeclOrStmtList
      {
          log_production("varDeclOrStmtList -> varDeclOrStmt varDeclOrStmtList");
          AST *head = $1;
          if ($2) ast_append_sibling(&head, $2);
          $$ = head;
      }
    | /* empty */
      {
          log_production("varDeclOrStmtList -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: localVarDeclOrStmt -> localVarDecl | statement */
varDeclOrStmt:
      localVarDecl
      {
          log_production("varDeclOrStmt -> localVarDecl");
          $$ = $1;
      }
    | statement
      {
          log_production("varDeclOrStmt -> statement");
          $$ = $1;
      }
;

/* Grammar Rule: localVarDecl -> local varDecl */
localVarDecl:
      LOCAL varDecl
      {
          log_production("localVarDecl -> LOCAL varDecl");
          $$ = $2;
      }
;

/* Grammar Rule: attributeDecl -> attribute varDecl */
attributeDecl:
      ATTRIBUTE varDecl
      {
          log_production("attributeDecl -> ATTRIBUTE varDecl");
          AST *attr = ast_new(NODE_ATTRIBUTE, NULL, @1.first_line);
          if ($2) ast_append_child(attr, $2);
          $$ = attr;
      }
;

/* Grammar Rule: varDecl -> id : type {{arraySize}} ;
 * LL(1) Transformation: varDecl -> ID : type arraySizes ;
 *   where arraySizes -> arraySize arraySizes | epsilon
 */
varDecl:
      ID COLON type arraySizes SEMICOLON
      {
          log_production("varDecl -> id : type arraySizes ;");
          AST *v = ast_new(NODE_VAR_DECL, $1, @1.first_line);
          if ($3) {
              v->typeName = $3->name ? strdup($3->name) : NULL;
              ast_free($3);
          }
          $$ = v;
      }
;

/* Helper rule for: {{arraySize}} in varDecl
 * Grammar: Zero or more array size specifications
 */
arraySizes:
      arraySize arraySizes
      {
          log_production("arraySizes -> arraySize arraySizes");
          $$ = NULL;
      }
    | /* empty */
      {
          log_production("arraySizes -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: arraySize -> [ intLit ] | [ ] */
arraySize:
      LBRACKET INT_LIT RBRACKET
      {
          log_production("arraySize -> [ INT ]");
          $$ = ast_new_int($2, @2.first_line);
      }
    | LBRACKET RBRACKET
      {
          log_production("arraySize -> [ ]");
          $$ = NULL;
      }
;

/* Grammar Rule: statement -> assignStat ; | if ( relExpr ) then statBlock else statBlock ;
 *   | while ( relExpr ) statBlock ; | read ( variable ) ; | write ( expr ) ;
 *   | return ( expr ) ; | functionCall ;
 */
statement:
      assignStat SEMICOLON
      {
          log_production("statement -> assignStat ;");
          $$ = $1;
      }
    | IF LPAREN expr RPAREN THEN statBlock ELSE statBlock SEMICOLON
      {
          log_production("statement -> IF ( expr ) THEN statBlock ELSE statBlock ;");
          AST *node = ast_new(NODE_IF, NULL, @1.first_line);
          ast_append_child(node, $3);
          ast_append_child(node, $6);
          ast_append_child(node, $8);
          $$ = node;
      }
    | IF LPAREN expr RPAREN THEN statBlock SEMICOLON
      {
          log_production("statement -> IF ( expr ) THEN statBlock ;");
          AST *node = ast_new(NODE_IF, NULL, @1.first_line);
          ast_append_child(node, $3);
          ast_append_child(node, $6);
          /* else block is NULL */
          $$ = node;
      }
    | WHILE LPAREN expr RPAREN statBlock SEMICOLON
      {
          log_production("statement -> WHILE ( expr ) statBlock ;");
          AST *node = ast_new(NODE_WHILE, NULL, @1.first_line);
          ast_append_child(node, $3);
          ast_append_child(node, $5);
          $$ = node;
      }
    | READ LPAREN variable RPAREN SEMICOLON
      {
          log_production("statement -> READ ( variable ) ;");
          AST *n = ast_new(NODE_READ, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | WRITE LPAREN expr RPAREN SEMICOLON
      {
          log_production("statement -> WRITE ( expr ) ;");
          AST *n = ast_new(NODE_WRITE, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | RETURN LPAREN expr RPAREN SEMICOLON
      {
          log_production("statement -> RETURN ( expr ) ;");
          AST *n = ast_new(NODE_RETURN, NULL, @1.first_line);
          ast_append_child(n, $3);
          $$ = n;
      }
    | functionCall SEMICOLON
      {
          log_production("statement -> functionCall ;");
          $$ = $1;
      }
    | error SEMICOLON
      {
          log_production("statement -> error ;");
          yyerror("Recovering from statement error");
          yyerrok;
          $$ = NULL;
      }
;

/* Grammar Rule: assignStat -> variable assignOp expr */
assignStat:
      variable ASSIGN expr
      {
          log_production("assignStat -> variable ASSIGN expr");
          AST *assign = ast_new(NODE_ASSIGN, NULL, @1.first_line);
          ast_append_child(assign, $1);
          ast_append_child(assign, $3);
          $$ = assign;
      }
;

/* Helper rule for: {{statement}} in statBlock
 * Grammar: Zero or more statements
 */
statementList:
      statement statementList
      {
          log_production("statementList -> statement statementList");
          AST *h = $1;
          if ($2) ast_append_sibling(&h, $2);
          $$ = h;
      }
    | /* empty */
      {
          log_production("statementList -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: statBlock -> { {{statement}} } | statement | ϵ
 * LL(1) Transformation: statBlock -> { statementList } | statement | epsilon
 */
statBlock:
      LBRACE statementList RBRACE
      {
          log_production("statBlock -> { statementList }");
          $$ = $2;
      }
    | statement
      {
          log_production("statBlock -> statement");
          $$ = $1;
      }
    | /* empty */
      {
          log_production("statBlock -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: expr -> arithExpr | relExpr */
expr:
      arithExpr
      {
          log_production("expr -> arithExpr");
          $$ = $1;
      }
    | relExpr
      {
          log_production("expr -> relExpr");
          $$ = $1;
      }
;

/* Grammar Rule: relExpr -> arithExpr relOp arithExpr */
relExpr:
      arithExpr EQ arithExpr
      {
          log_production("relExpr -> arithExpr == arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "==", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr NE arithExpr
      {
          log_production("relExpr -> arithExpr <> arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<>", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr LT arithExpr
      {
          log_production("relExpr -> arithExpr < arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr GT arithExpr
      {
          log_production("relExpr -> arithExpr > arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, ">", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr LE arithExpr
      {
          log_production("relExpr -> arithExpr <= arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, "<=", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
    | arithExpr GE arithExpr
      {
          log_production("relExpr -> arithExpr >= arithExpr");
          AST *n = ast_new(NODE_BINARY_OP, ">=", @2.first_line);
          ast_append_child(n, $1);
          ast_append_child(n, $3);
          $$ = n;
      }
;

/* Grammar Rule: arithExpr -> arithExpr addOp term | term
 * LL(1) Transformation: arithExpr -> term arithExprPrime
 *   where arithExprPrime -> addOp term arithExprPrime | epsilon
 */
arithExpr:
      term arithExprPrime
      {
          log_production("arithExpr -> term arithExprPrime");
          if ($2) {
              AST *op = $2;
              AST *left = $1;
              AST *right = op->child;
              op->child = left;
              if (right) {
                  op->child->sibling = right;
              }
              $$ = op;
          } else {
              $$ = $1;
          }
      }
;

/* Helper rule for right-recursive arithExpr
 * Eliminates left recursion: arithExpr -> arithExpr addOp term
 */
arithExprPrime:
      addOp term arithExprPrime
      {
          log_production("arithExprPrime -> addOp term arithExprPrime");
          AST *op = ast_new(NODE_BINARY_OP, $1, @1.first_line);
          op->child = $2;  /* right operand (term) */
          if ($3) {
              AST *chain = $3;
              chain->child->sibling = op;
              $$ = chain;
          } else {
              $$ = op;
          }
          free($1);
      }
    | /* empty */
      {
          log_production("arithExprPrime -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: addOp -> + | - | or */
addOp:
      PLUS
      {
          log_production("addOp -> +");
          $$ = strdup("+");
      }
    | MINUS
      {
          log_production("addOp -> -");
          $$ = strdup("-");
      }
    | OR
      {
          log_production("addOp -> or");
          $$ = strdup("or");
      }
;

/* Grammar Rule: term -> term multOp factor | factor
 * LL(1) Transformation: term -> factor termPrime
 *   where termPrime -> multOp factor termPrime | epsilon
 */
term:
      factor termPrime
      {
          log_production("term -> factor termPrime");
          if ($2) {
              AST *op = $2;
              AST *left = $1;
              AST *right = op->child;
              op->child = left;
              if (right) {
                  op->child->sibling = right;
              }
              $$ = op;
          } else {
              $$ = $1;
          }
      }
;

/* Helper rule for right-recursive term
 * Eliminates left recursion: term -> term multOp factor
 */
termPrime:
      multOp factor termPrime
      {
          log_production("termPrime -> multOp factor termPrime");
          AST *op = ast_new(NODE_BINARY_OP, $1, @1.first_line);
          op->child = $2;  /* right operand (factor) */
          if ($3) {
              AST *chain = $3;
              chain->child->sibling = op;
              $$ = chain;
          } else {
              $$ = op;
          }
          free($1);
      }
    | /* empty */
      {
          log_production("termPrime -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: multOp -> * | / | and */
multOp:
      MULT
      {
          log_production("multOp -> *");
          $$ = strdup("*");
      }
    | DIV
      {
          log_production("multOp -> /");
          $$ = strdup("/");
      }
    | AND
      {
          log_production("multOp -> and");
          $$ = strdup("and");
      }
;

/* Grammar Rule: factor -> variable | functionCall | intLit | floatLit | ( arithExpr ) | not factor | sign factor */
factor:
      variable
      {
          log_production("factor -> variable");
          $$ = $1;
      }
    | functionCall
      {
          log_production("factor -> functionCall");
          $$ = $1;
      }
    | INT_LIT
      {
          log_production("factor -> INT_LIT");
          AST *n = ast_new(NODE_INT_LITERAL, NULL, @1.first_line);
          n->intValue = $1;
          $$ = n;
      }
    | FLOAT_LIT
      {
          log_production("factor -> FLOAT_LIT");
          AST *n = ast_new(NODE_FLOAT_LITERAL, NULL, @1.first_line);
          n->floatValue = $1;
          $$ = n;
      }
    | LPAREN arithExpr RPAREN
      {
          log_production("factor -> ( arithExpr )");
          $$ = $2;
      }
    | NOT factor
      {
          log_production("factor -> NOT factor");
          AST *n = ast_new(NODE_UNARY_OP, "not", @1.first_line);
          ast_append_child(n, $2);
          $$ = n;
      }
    | sign factor
      {
          log_production("factor -> sign factor");
          AST *n = ast_new(NODE_UNARY_OP, $1, @1.first_line);
          ast_append_child(n, $2);
          free($1);
          $$ = n;
      }
;

/* Grammar Rule: sign -> + | - */
sign:
      PLUS
      {
          log_production("sign -> +");
          $$ = strdup("+");
      }
    | MINUS
      {
          log_production("sign -> -");
          $$ = strdup("-");
      }
;

/* Grammar Rule: functionCall -> {{idnest}} id ( aParams )
 * LL(1) Transformation: functionCall -> idnest DOT functionCall | ID ( aParams )
 */
functionCall:
      ID LPAREN aParams RPAREN
      {
          log_production("functionCall -> id ( aParams )");
          AST *c = ast_new(NODE_FUNCTION_CALL, $1, @1.first_line);
          if ($3) c->child = $3;
          $$ = c;
      }
    | idnest DOT functionCall
      {
          log_production("functionCall -> idnest . functionCall");
          AST *c = $3;
          if ($1) {
              if (c->child) {
                  AST *last = $1;
                  while (last->sibling) last = last->sibling;
                  last->sibling = c->child;
                  c->child = $1;
              } else {
                  c->child = $1;
              }
          }
          $$ = c;
      }
;

/* Grammar Rule: variable -> {{idnest}} id {{indice}}
 * LL(1) Transformation: variable -> idOrSelf DOT ID indiceList | idnest DOT variable | ID indiceList
 *   where indiceList -> indice indiceList | epsilon
 *   Note: idOrSelf DOT ID handles base cases like self.field or obj.field (non-recursive)
 */
variable:
      ID indiceList
      {
          log_production("variable -> id indiceList");
          AST *var = ast_new(NODE_ID, $1, @1.first_line);
          if ($2) var->sibling = $2;
          $$ = var;
      }
    | idOrSelf DOT ID indiceList
      {
          log_production("variable -> idOrSelf . id indiceList");
          AST *var = ast_new(NODE_ID, $3, @3.first_line);
          if ($4) var->sibling = $4;
          if ($1) {
              AST *last = $1;
              while (last->sibling) last = last->sibling;
              last->sibling = var;
              var = $1;
          }
          $$ = var;
      }
    | idnest DOT variable
      {
          log_production("variable -> idnest . variable");
          AST *var = $3;
          if ($1) {
              AST *last = $1;
              while (last->sibling) last = last->sibling;
              last->sibling = var;
              var = $1;
          }
          $$ = var;
      }
;



/* Grammar Rule: idnest -> idOrSelf {{indice}}. | idOrSelf ( aParams ) .
 * LL(1) Transformation: idnest -> idOrSelf indiceList DOT | idOrSelf ( aParams ) DOT
 */
idnest:
      idOrSelf indiceList DOT
      {
          log_production("idnest -> idOrSelf indiceList .");
          AST *n = $1;
          if ($2) {
              if (n->sibling) {
                  AST *last = n;
                  while (last->sibling) last = last->sibling;
                  last->sibling = $2;
              } else {
                  n->sibling = $2;
              }
          }
          $$ = n;
      }
    | idOrSelf LPAREN aParams RPAREN DOT
      {
          log_production("idnest -> idOrSelf ( aParams ) .");
          AST *call = ast_new(NODE_FUNCTION_CALL, $1->name, @1.first_line);
          call->child = $3;
          $$ = call;
      }
;

/* Grammar Rule: idOrSelf -> id | self */
idOrSelf:
      ID
      {
          log_production("idOrSelf -> id");
          $$ = ast_new(NODE_ID, $1, @1.first_line);
      }
    | SELF
      {
          log_production("idOrSelf -> self");
          $$ = ast_new(NODE_ID, "self", @1.first_line);
      }
;

/* Helper rule for: {{indice}} in variable and idnest
 * Grammar: Zero or more array indices
 */
indiceList:
      indice indiceList
      {
          log_production("indiceList -> indice indiceList");
          AST *head = $1;
          if ($2) ast_append_sibling(&head, $2);
          $$ = head;
      }
    | /* empty */
      {
          log_production("indiceList -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: indice -> [ arithExpr ] */
indice:
      LBRACKET arithExpr RBRACKET
      {
          log_production("indice -> [ arithExpr ]");
          AST *idx = ast_new(NODE_BINARY_OP, "[]", @1.first_line);
          ast_append_child(idx, $2);
          $$ = idx;
      }
;

/* Grammar Rule: fParams -> id : type {{arraySize}} {{fParamsTail}} | ϵ
 * LL(1) Transformation: fParams -> ID : type arraySizes fParamsTailList | epsilon
 *   where fParamsTailList -> COMMA ID : type arraySizes fParamsTailList | epsilon
 */
fParams:
      ID COLON type arraySizes fParamsTailList
      {
          log_production("fParams -> id : type arraySizes fParamsTailList");
          AST *p = ast_new(NODE_PARAM, $1, @1.first_line);
          if ($3) {
              p->typeName = $3->name ? strdup($3->name) : NULL;
              ast_free($3);
          }
          if ($5) ast_append_sibling(&p, $5);
          $$ = p;
      }
    | /* empty */
      {
          log_production("fParams -> epsilon");
          $$ = NULL;
      }
;

/* Helper rule for: {{fParamsTail}} in fParams
 * Grammar Rule: fParamsTail -> , id : type {{arraySize}}
 */
fParamsTailList:
      COMMA ID COLON type arraySizes fParamsTailList
      {
          log_production("fParamsTailList -> , id : type arraySizes fParamsTailList");
          AST *p = ast_new(NODE_PARAM, $2, @2.first_line);
          if ($4) {
              p->typeName = $4->name ? strdup($4->name) : NULL;
              ast_free($4);
          }
          if ($6) ast_append_sibling(&p, $6);
          $$ = p;
      }
    | /* empty */
      {
          log_production("fParamsTailList -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: aParams -> expr {{aParamsTail}} | ϵ
 * LL(1) Transformation: aParams -> expr aParamsTailList | epsilon
 *   where aParamsTailList -> COMMA expr aParamsTailList | epsilon
 */
aParams:
      expr aParamsTailList
      {
          log_production("aParams -> expr aParamsTailList");
          AST *h = $1;
          if ($2) ast_append_sibling(&h, $2);
          $$ = h;
      }
    | /* empty */
      {
          log_production("aParams -> epsilon");
          $$ = NULL;
      }
;

/* Helper rule for: {{aParamsTail}} in aParams
 * Grammar Rule: aParamsTail -> , expr
 */
aParamsTailList:
      COMMA expr aParamsTailList
      {
          log_production("aParamsTailList -> , expr aParamsTailList");
          AST *n = $2;
          if ($3) ast_append_sibling(&n, $3);
          $$ = n;
      }
    | /* empty */
      {
          log_production("aParamsTailList -> epsilon");
          $$ = NULL;
      }
;

/* Grammar Rule: type -> integer | float | id */
type:
      INTEGER_T
      {
          log_production("type -> INTEGER");
          AST *t = ast_new(NODE_TYPE, "int", @1.first_line);
          $$ = t;
      }
    | FLOAT_T
      {
          log_production("type -> FLOAT");
          AST *t = ast_new(NODE_TYPE, "float", @1.first_line);
          $$ = t;
      }
    | ID
      {
          log_production("type -> id");
          AST *t = ast_new(NODE_TYPE, $1, @1.first_line);
          $$ = t;
      }
;

/* Grammar Rule: returnType -> type | void */
returnType:
      type
      {
          log_production("returnType -> type");
          $$ = $1;
      }
    | VOID
      {
          log_production("returnType -> VOID");
          AST *t = ast_new(NODE_TYPE, "void", @1.first_line);
          $$ = t;
      }
;

%%

static void log_production(const char *rule) {
    if (derivation_file && rule) {
        fprintf(derivation_file, "%s\n", rule);
        fflush(derivation_file);
    }
}

void yyerror(const char *s) {
    fprintf(stderr, "Syntax error at line %d: %s\n", current_line, s);
}
